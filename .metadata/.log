!SESSION 2022-08-31 09:23:41.737 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\Users\PJain15\RestAssured_RahulShetty\.metadata\.bak_0.log
Created Time: 2022-08-31 16:35:18.621

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-08-31 16:35:18.621
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-08-31 16:35:18.625
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-08-31 16:37:43.955
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.restassured.internal

import io.restassured.RestAssured
import io.restassured.authentication.AuthenticationScheme
import io.restassured.authentication.CertAuthScheme
import io.restassured.authentication.FormAuthScheme
import io.restassured.authentication.NoAuthScheme
import io.restassured.config.*
import io.restassured.filter.Filter
import io.restassured.filter.OrderedFilter
import io.restassured.filter.log.RequestLoggingFilter
import io.restassured.filter.log.ResponseLoggingFilter
import io.restassured.filter.time.TimingFilter
import io.restassured.http.*
import io.restassured.internal.MapCreator.CollisionStrategy
import io.restassured.internal.filter.FilterContextImpl
import io.restassured.internal.filter.FormAuthFilter
import io.restassured.internal.filter.SendRequestFilter
import io.restassured.internal.http.*
import io.restassured.internal.log.LogRepository
import io.restassured.internal.mapping.ObjectMapperSerializationContextImpl
import io.restassured.internal.mapping.ObjectMapping
import io.restassured.internal.multipart.MultiPartInternal
import io.restassured.internal.multipart.MultiPartSpecificationImpl
import io.restassured.internal.multipart.RestAssuredMultiPartEntity
import io.restassured.internal.proxy.RestAssuredProxySelector
import io.restassured.internal.proxy.RestAssuredProxySelectorRoutePlanner
import io.restassured.internal.support.ParameterUpdater
import io.restassured.internal.support.PathSupport
import io.restassured.mapper.ObjectMapper
import io.restassured.mapper.ObjectMapperType
import io.restassured.parsing.Parser
import io.restassured.response.Response
import io.restassured.specification.*
import io.restassured.spi.AuthFilter
import org.apache.http.HttpEntity
import org.apache.http.HttpResponse
import org.apache.http.auth.AuthScope
import org.apache.http.auth.UsernamePasswordCredentials
import org.apache.http.client.CredentialsProvider
import org.apache.http.client.HttpClient
import org.apache.http.client.methods.HttpPost
import org.apache.http.client.methods.HttpRequestBase
import org.apache.http.entity.HttpEntityWrapper
import org.apache.http.entity.mime.FormBodyPartBuilder
import org.apache.http.impl.client.AbstractHttpClient
import org.apache.http.impl.client.BasicCredentialsProvider
import org.apache.http.message.BasicHeader
import org.apache.http.util.EntityUtils

import java.nio.charset.StandardCharsets
import java.security.KeyStore
import java.util.Map.Entry
import java.util.regex.Matcher
import java.util.regex.Pattern

import static io.restassured.config.ParamConfig.UpdateStrategy.REPLACE
import static io.restassured.http.ContentType.*
import static io.restassured.http.Method.*
import static io.restassured.internal.common.assertion.AssertParameter.notNull
import static io.restassured.internal.serialization.SerializationSupport.isSerializableCandidate
import static io.restassured.internal.support.PathSupport.isFullyQualified
import static io.restassured.internal.support.PathSupport.mergeAndRemoveDoubleSlash
import static java.lang.String.format
import static java.util.Arrays.asList
import static org.apache.commons.lang3.StringUtils.*
import static org.apache.http.client.params.ClientPNames.*

class RequestSpecificationImpl implements FilterableRequestSpecification, GroovyInterceptable {
  private static final int DEFAULT_HTTP_TEST_PORT = 8080
  private static final String CONTENT_TYPE = "Content-Type"
  private static final String DOUBLE_SLASH = "//"
  private static final String LOCALHOST = "localhost"
  private static final String CHARSET = "charset"
  private static final String ACCEPT_HEADER_NAME = "Accept"
  private static final String SSL = "SSL"
  private static final String MULTIPART = "multipart"
  private static final String MULTIPART_CONTENT_TYPE_PREFIX_WITH_SLASH = MULTIPART + "/"
  private static final String MULTIPART_CONTENT_TYPE_PREFIX_WITH_PLUS = MULTIPART + "+"
  private static final String APPLICATION_JSON = "application/json"
  private static final String TEMPLATE_START = "{"
  private static final String TEMPLATE_END = "}"

  private String baseUri
  private String path = ""
  private String method
  private String basePath
  // If first argument is null it means that it's a redundant path param that cannot be mapped to a placeholder
  // If second argument is null it means that the parameter has been removed (but we keep it to retain order)
  private List<Tuple2<String, String>> unnamedPathParamsTuples = new ArrayList<>()
  private AuthenticationScheme defaultAuthScheme
  private int port
  private Map<String, String> requestParameters = new LinkedHashMap()
  private Map<String, String> queryParameters = new LinkedHashMap()
  private Map<String, String> formParameters = new LinkedHashMap()
  private Map<String, String> namedPathParameters = [:]
  private Map<String, String> httpClientParams = [:]
  AuthenticationScheme authenticationScheme = new NoAuthScheme()
  private FilterableResponseSpecification responseSpecification
  private Headers requestHeaders = new Headers([])
  private Cookies cookies = new Cookies([])
  private Object requestBody
  private List<Filter> filters = []
  private boolean urlEncodingEnabled
  private RestAssuredConfig restAssuredConfig
  private List<MultiPartInternal> multiParts = []
  private ParameterUpdater parameterUpdater = new ParameterUpdater(new ParameterUpdater.Serializer() {
    String serializeIfNeeded(Object value) {
      return RequestSpecificationImpl.this.serializeIfNeeded(value)
    }
  })
  private ProxySpecification proxySpecification = null

  private LogRepository logRepository

  // This field should be removed once http://jira.codehaus.org/browse/GROOVY-4647 is resolved, merge with sha 9619c3b when it's fixed.
  private AbstractHttpClient httpClient

  private boolean allowContentType

  RequestSpecificationImpl(String baseURI, int requestPort, String basePath, AuthenticationScheme defaultAuthScheme, List<Filter> filters,
                           RequestSpecification defaultSpec, boolean urlEncode, RestAssuredConfig restAssuredConfig, LogRepository logRepository,
                           ProxySpecification proxySpecification, boolean allowContentType) {
    notNull(baseURI, "baseURI")
    notNull(basePath, "basePath")
    notNull(defaultAuthScheme, "defaultAuthScheme")
    notNull(filters, "Filters")
    notNull(urlEncode, "URL Encode query params option")
    this.baseUri = baseURI
    this.basePath = basePath
    this.defaultAuthScheme = defaultAuthScheme
    this.filters.addAll(filters)
    this.urlEncodingEnabled = urlEncode
    port(requestPort)
    this.restAssuredConfig = restAssuredConfig
    if (defaultSpec != null) {
      spec(defaultSpec)
    }
    this.logRepository = logRepository
    this.proxySpecification = proxySpecification
    this.allowContentType = allowContentType
  }

  RequestSpecification when() {
    return this
  }

  RequestSpecification given() {
    return this
  }

  RequestSpecification that() {
    return this
  }

  ResponseSpecification response() {
    return responseSpecification
  }

  Response get(String path, Object... pathParams) {
    applyPathParamsAndSendRequest(GET, path, pathParams)
  }

  Response post(String path, Object... pathParams) {
    applyPathParamsAndSendRequest(POST, path, pathParams)
  }

  Response put(String path, Object... pathParams) {
    applyPathParamsAndSendRequest(PUT, path, pathParams)
  }

  Response delete(String path, Object... pathParams) {
    applyPathParamsAndSendRequest(DELETE, path, pathParams)
  }

  Response head(String path, Object... pathParams) {
    applyPathParamsAndSendRequest(HEAD, path, pathParams)
  }

  Response patch(String path, Object... pathParams) {
    applyPathParamsAndSendRequest(PATCH, path, pathParams)
  }

  Response options(String path, Object... pathParams) {
    applyPathParamsAndSendRequest(OPTIONS, path, pathParams)
  }

  Response get(URI uri) {
    get(notNull(uri, "URI").toString())
  }

  Response post(URI uri) {
    post(notNull(uri, "URI").toString())
  }

  Response put(URI uri) {
    put(notNull(uri, "URI").toString())
  }

  Response delete(URI uri) {
    delete(notNull(uri, "URI").toString())
  }

  Response head(URI uri) {
    head(notNull(uri, "URI").toString())
  }

  Response patch(URI uri) {
    patch(notNull(uri, "URI").toString())
  }

  Response options(URI uri) {
    options(notNull(uri, "URI").toString())
  }

  Response get(URL url) {
    get(notNull(url, "URL").toString())
  }

  Response post(URL url) {
    post(notNull(url, "URL").toString())
  }

  Response put(URL url) {
    put(notNull(url, "URL").toString())
  }

  Response delete(URL url) {
    delete(notNull(url, "URL").toString())
  }

  Response head(URL url) {
    head(notNull(url, "URL").toString())
  }

  Response patch(URL url) {
    patch(notNull(url, "URL").toString())
  }

  Response options(URL url) {
    options(notNull(url, "URL").toString())
  }

  Response get() {
    get("")
  }

  Response post() {
    post("")
  }

  Response put() {
    put("")
  }

  Response delete() {
    delete("")
  }

  Response head() {
    head("")
  }

  Response patch() {
    patch("")
  }

  Response options() {
    options("")
  }

  Response request(Method method) {
    request(notNull(method, Method.class).name())
  }

  Response request(String method) {
    request(method, "")
  }

  Response request(Method method, String path, Object... pathParams) {
    return request(notNull(method, Method.class).name(), path, pathParams)
  }

  Response request(String method, String path, Object... pathParams) {
    applyPathParamsAndSendRequest(method, path, pathParams)
  }

  Response request(Method method, URI uri) {
    request(method, notNull(uri, URI.class).toString())
  }

  Response request(Method method, URL url) {
    request(method, notNull(url, URL.class).toString())
  }

  Response request(String method, URI uri) {
    request(method, notNull(uri, URI.class).toString())
  }

  Response request(String method, URL url) {
    request(method, notNull(url, URL.class).toString())
  }

  Response get(String path, Map pathParamsMap) {
    pathParams(pathParamsMap)
    applyPathParamsAndSendRequest(GET, path)
  }

  Response post(String path, Map pathParamsMap) {
    pathParams(pathParamsMap)
    applyPathParamsAndSendRequest(POST, path)
  }

  Response put(String path, Map pathParamsMap) {
    pathParams(pathParamsMap)
    applyPathParamsAndSendRequest(PUT, path)
  }

  Response delete(String path, Map pathParamsMap) {
    pathParams(pathParamsMap)
    applyPathParamsAndSendRequest(DELETE, path)
  }

  Response head(String path, Map pathParamsMap) {
    pathParams(pathParamsMap)
    applyPathParamsAndSendRequest(HEAD, path)
  }

  Response patch(String path, Map pathParamsMap) {
    pathParams(pathParamsMap)
    applyPathParamsAndSendRequest(PATCH, path)
  }

  Response options(String path, Map pathParamsMap) {
    pathParams(pathParamsMap)
    applyPathParamsAndSendRequest(OPTIONS, path)
  }

  RequestSpecification params(String firstParameterName, Object firstParameterValue, Object... parameterNameValuePairs) {
    notNull firstParameterName, "firstParameterName"
    notNull firstParameterValue, "firstParameterValue"
    return params(MapCreator.createMapFromParams(CollisionStrategy.OVERWRITE, firstParameterName, firstParameterValue, parameterNameValuePairs))
  }

  RequestSpecification params(Map parametersMap) {
    notNull parametersMap, "parametersMap"
    parameterUpdater.updateParameters(restAssuredConfig().paramConfig.requestParamsUpdateStrategy(), parametersMap, requestParameters)
    return this
  }

  RequestSpecification param(String parameterName, Object... parameterValues) {
    notNull parameterName, "parameterName"
    parameterUpdater.updateZeroToManyParameters(restAssuredConfig().paramConfig.requestParamsUpdateStrategy(), requestParameters, parameterName, parameterValues)
    return this
  }

  FilterableRequestSpecification removeParam(String parameterName) {
    notNull parameterName, "parameterName"
    requestParameters.remove(parameterName)
    return this
  }

  RequestSpecification param(String parameterName, Collection<?> parameterValues) {
    notNull parameterValues, "parameterValues"
    return param(parameterName, parameterValues.toArray())
  }

  RequestSpecification queryParam(String parameterName, Collection<?> parameterValues) {
    notNull parameterName, "parameterName"
    notNull parameterValues, "parameterValues"
    parameterUpdater.updateCollectionParameter(restAssuredConfig().getParamConfig().queryParamsUpdateStrategy(), queryParameters, parameterName, parameterValues)
    return this
  }

  FilterableRequestSpecification removeQueryParam(String parameterName) {
    notNull parameterName, "parameterName"
    queryParameters.remove(parameterName)
    return this
  }

  FilterableRequestSpecification removeHeader(String headerName) {
    notNull headerName, "headerName"
    def headersLeftAfterRemove = headers.findAll { !headerName.equalsIgnoreCase(it.getName()) }
    this.requestHeaders = new Headers(headersLeftAfterRemove)
    this
  }

  FilterableRequestSpecification removeCookie(String cookieName) {
    notNull cookieName, "cookieName"
    def cookiesLeftAfterRemove = cookies.findAll { !cookieName.equalsIgnoreCase(it.getName()) }
    this.cookies = new Cookies(cookiesLeftAfterRemove)
    this
  }

  FilterableRequestSpecification removeCookie(Cookie cookie) {
    notNull cookie, "cookie"
    removeCookie(cookie.getName())
    this
  }

  FilterableRequestSpecification replaceHeader(String headerName, String newValue) {
    notNull headerName, "headerName"
    removeHeader(headerName)
    def headerList = []
    headerList.addAll(this.requestHeaders.list())
    headerList.add(new Header(headerName, newValue))
    this.requestHeaders = new Headers(headerList)
    this
  }

  FilterableRequestSpecification replaceCookie(String cookieName, String value) {
    notNull cookieName, "cookieName"
    removeCookie(cookieName)
    cookie(cookieName, value)
    this
  }

  FilterableRequestSpecification replaceCookie(Cookie cookie) {
    notNull cookie, "cookie"
    removeCookie(cookie.getName())
    this.cookie(cookie)
    this
  }

  FilterableRequestSpecification replaceHeaders(Headers headers) {
    notNull headers, "headers"
    this.requestHeaders = new Headers(headers.asList())
    this
  }

  FilterableRequestSpecification replaceCookies(Cookies cookies) {
    notNull cookies, "cookies"
    this.cookies = new Cookies(cookies.asList())
    this
  }

  FilterableRequestSpecification removeHeaders() {
    this.requestHeaders = new Headers([])
    this
  }

  FilterableRequestSpecification removeCookies() {
    this.cookies = new Cookies([])
    this
  }


  RequestSpecification queryParams(String firstParameterName, Object firstParameterValue, Object... parameterNameValuePairs) {
    notNull firstParameterName, "firstParameterName"
    notNull firstParameterValue, "firstParameterValue"
    return queryParams(MapCreator.createMapFromParams(CollisionStrategy.OVERWRITE, firstParameterName, firstParameterValue, parameterNameValuePairs))
  }

  RequestSpecification queryParams(Map parametersMap) {
    notNull parametersMap, "parametersMap"
    parameterUpdater.updateParameters(restAssuredConfig().paramConfig.queryParamsUpdateStrategy(), parametersMap, queryParameters)
    return this
  }

  RequestSpecification queryParam(String parameterName, Object... parameterValues) {
    notNull parameterName, "parameterName"
    parameterUpdater.updateZeroToManyParameters(restAssuredConfig().paramConfig.queryParamsUpdateStrategy(), queryParameters, parameterName, parameterValues)
    return this
  }

  RequestSpecification formParam(String parameterName, Collection<?> parameterValues) {
    notNull parameterName, "parameterName"
    notNull parameterValues, "parameterValues"
    parameterUpdater.updateCollectionParameter(restAssuredConfig().paramConfig.formParamsUpdateStrategy(), formParameters, parameterName, parameterValues)
    return this
  }

  FilterableRequestSpecification removeFormParam(String parameterName) {
    notNull parameterName, "parameterName"
    formParameters.remove(parameterName)
    return this
  }

  RequestSpecification formParams(String firstParameterName, Object firstParameterValue, Object... parameterNameValuePairs) {
    notNull firstParameterName, "firstParameterName"
    notNull firstParameterValue, "firstParameterValue"
    return formParams(MapCreator.createMapFromParams(CollisionStrategy.OVERWRITE, firstParameterName, firstParameterValue, parameterNameValuePairs))
  }

  RequestSpecification formParams(Map parametersMap) {
    notNull parametersMap, "parametersMap"
    parameterUpdater.updateParameters(restAssuredConfig().paramConfig.formParamsUpdateStrategy(), parametersMap, formParameters)
    return this
  }

  RequestSpecification formParam(String parameterName, Object... additionalParameterValues) {
    notNull parameterName, "parameterName"
    parameterUpdater.updateZeroToManyParameters(restAssuredConfig().paramConfig.formParamsUpdateStrategy(), formParameters, parameterName, additionalParameterValues)
    return this
  }

  RequestSpecification urlEncodingEnabled(boolean isEnabled) {
    this.urlEncodingEnabled = isEnabled
    return this
  }

  RequestSpecification pathParam(String parameterName, Object parameterValue) {
    notNull parameterName, "parameterName"
    notNull parameterValue, "parameterValue"
    parameterUpdater.updateStandardParameter(REPLACE, namedPathParameters, parameterName, parameterValue)
    return this
  }

  RequestSpecification pathParams(String firstParameterName, Object firstParameterValue, Object... parameterNameValuePairs) {
    notNull firstParameterName, "firstParameterName"
    notNull firstParameterValue, "firstParameterValue"
    return pathParams(MapCreator.createMapFromParams(CollisionStrategy.OVERWRITE, firstParameterName, firstParameterValue, parameterNameValuePairs))
  }

  RequestSpecification pathParams(Map parameterNameValuePairs) {
    notNull parameterNameValuePairs, "parameterNameValuePairs"
    parameterUpdater.updateParameters(REPLACE, parameterNameValuePairs, namedPathParameters)
    return this
  }

  FilterableRequestSpecification removePathParam(String parameterName) {
    notNull parameterName, "parameterName"
    removeNamedPathParam(parameterName)
    removeUnnamedPathParam(parameterName)
    return this
  }

  FilterableRequestSpecification removeNamedPathParam(String parameterName) {
    notNull parameterName, "parameterName"
    namedPathParameters.remove(parameterName)
    this
  }

  FilterableRequestSpecification removeUnnamedPathParam(String parameterName) {
    notNull parameterName, "parameterName"
    def indexOfParamName = unnamedPathParamsTuples.findIndexOf { it.v1 == parameterName }
    if (indexOfParamName > -1) {
      removeUnnamedPathParamAtIndex(indexOfParamName)
    }
    this
  }

  FilterableRequestSpecification removeUnnamedPathParamByValue(String parameterValue) {
    notNull parameterValue, "parameterValue"
    def indexOfParamValue = unnamedPathParamsTuples.findIndexOf { it.v2 == parameterValue }
    if (indexOfParamValue > -1) {
      removeUnnamedPathParamAtIndex(indexOfParamValue)
    }
    return this
  }

  RequestSpecification config(RestAssuredConfig config) {
    this.restAssuredConfig = config
    responseSpecification?.config = config
    this
  }

  RequestSpecification keyStore(String pathToJks, String password) {
    def sslConfig = restAssuredConfig().getSSLConfig()
    // Allow all host names in order to be backward compatible
    restAssuredConfig = restAssuredConfig().sslConfig(sslConfig.keyStore(pathToJks, password).allowAllHostnames())
    this
  }

  RequestSpecification keyStore(File pathToJks, String password) {
    def sslConfig = restAssuredConfig().getSSLConfig()
    // Allow all host names in order to be backward compatible
    restAssuredConfig = restAssuredConfig().sslConfig(sslConfig.keyStore(pathToJks, password).allowAllHostnames())
    this
  }

  RequestSpecification trustStore(String path, String password) {
    def sslConfig = restAssuredConfig().getSSLConfig()
    restAssuredConfig = restAssuredConfig().sslConfig(sslConfig.trustStore(path, password).allowAllHostnames())
    this
  }

  RequestSpecification trustStore(File path, String password) {
    def sslConfig = restAssuredConfig().getSSLConfig()
    restAssuredConfig = restAssuredConfig().sslConfig(sslConfig.trustStore(path, password).allowAllHostnames())
    this
  }

  RequestSpecification trustStore(KeyStore trustStore) {
    def sslConfig = restAssuredConfig().getSSLConfig()
    restAssuredConfig = restAssuredConfig().sslConfig(sslConfig.trustStore(trustStore))
    this
  }

  RequestSpecification keyStore(KeyStore keyStore) {
    def sslConfig = restAssuredConfig().getSSLConfig()
    restAssuredConfig = restAssuredConfig().sslConfig(sslConfig.keyStore(keyStore))
    this
  }

  RequestSpecification relaxedHTTPSValidation() {
    relaxedHTTPSValidation(SSL)
  }

  RequestSpecification relaxedHTTPSValidation(String protocol) {
    def sslConfig = restAssuredConfig().getSSLConfig()
    restAssuredConfig = restAssuredConfig().sslConfig(sslConfig.relaxedHTTPSValidation(protocol))
    this
  }

  RequestSpecification filter(Filter filter) {
    notNull filter, "Filter"
    filters << filter
    return this
  }

  RequestSpecification filters(List<Filter> filters) {
    notNull filters, "Filters"
    this.filters.addAll(filters)
    return this
  }

  RequestSpecification filters(Filter filter, Filter... additionalFilter) {
    notNull filter, "Filter"
    this.filters.add(filter)
    additionalFilter?.each {
      this.filters.add(it)
    }
    return this
  }

  RequestLogSpecification log() {
    def blacklistedHeaders = restAssuredConfig().logConfig.blacklistedHeaders()
    return new RequestLogSpecificationImpl(requestSpecification: this, logRepository: logRepository, blacklistedHeaders: blacklistedHeaders)
  }

  RequestSpecification and() {
    return this
  }

  RequestSpecification request() {
    return this
  }

  RequestSpecification with() {
    return this
  }

  ResponseSpecification then() {
    return responseSpecification
  }

  ResponseSpecification expect() {
    return responseSpecification
  }

  AuthenticationSpecification auth() {
    return new AuthenticationSpecificationImpl(this)
  }

  AuthenticationSpecification authentication() {
    return auth()
  }

  RequestSpecification port(int port) {
    if (port < 1 && port != RestAssured.UNDEFINED_PORT) {
      throw new IllegalArgumentException("Port must be greater than 0")
    }
    this.port = port
    return this
  }

  RequestSpecification body(String body) {
    notNull body, "body"
    this.requestBody = body
    return this
  }

  RequestSpecification baseUri(String baseUri) {
    notNull baseUri, "Base URI"
    this.baseUri = baseUri
    return this
  }

  RequestSpecification basePath(String basePath) {
    notNull basePath, "Base Path"
    this.basePath = basePath
    return this
  }

  RequestSpecification proxy(String host, int port) {
    proxy(ProxySpecification.host(host).withPort(port))
  }

  RequestSpecification proxy(String host) {
    if (UriValidator.isUri(host)) {
      proxy(new URI(host))
    } else {
      proxy(ProxySpecification.host(host))
    }
  }

  RequestSpecification proxy(int port) {
    proxy(ProxySpecification.port(port))
  }

  RequestSpecification proxy(String host, int port, String scheme) {
    proxy(new org.apache.http.client.utils.URIBuilder().setHost(host).setPort(port).setScheme(scheme).build())
  }

  RequestSpecification proxy(URI uri) {
    notNull(uri, URI.class)
    proxy(new ProxySpecification(uri.host, uri.port, uri.scheme))
  }

  RequestSpecification proxy(ProxySpecification proxySpecification) {
    notNull(proxySpecification, ProxySpecification.class)
    this.proxySpecification = proxySpecification
    this
  }

  RequestSpecification body(byte[] body) {
    notNull body, "body"
    this.requestBody = body
    return this
  }

  RequestSpecification body(File body) {
    notNull body, "body"
    this.requestBody = body
    return this
  }

  RequestSpecification body(InputStream body) {
    notNull body, "body"
    this.requestBody = body
    return this
  }

  RequestSpecification body(Object object) {
    notNull object, "object"
    if (!isSerializableCandidate(object)) {
      return body(object.toString())
    }

    this.requestBody = ObjectMapping.serialize(object, requestContentType, findEncoderCharsetOrReturnDefault(requestContentType), null, objectMappingConfig(), restAssuredConfig().getEncoderConfig())
    this
  }

  RequestSpecification body(Object object, ObjectMapper mapper) {
    notNull object, "object"
    notNull mapper, "Object mapper"
    def ctx = new ObjectMapperSerializationContextImpl()
    ctx.setObject(object)
    ctx.setCharset(findEncoderCharsetOrReturnDefault(requestContentType))
    ctx.setContentType(requestContentType)
    this.requestBody = mapper.serialize(ctx)
    this
  }

  RequestSpecification body(Object object, ObjectMapperType mapperType) {
    notNull object, "object"
    notNull mapperType, "Object mapper type"
    this.requestBody = ObjectMapping.serialize(object, requestContentType, findEncoderCharsetOrReturnDefault(requestContentType), mapperType, objectMappingConfig(), restAssuredConfig().getEncoderConfig())
    this
  }

  RequestSpecification contentType(ContentType contentType) {
    notNull contentType, ContentType.class
    allowContentType = true
    header(CONTENT_TYPE, contentType)
  }

  RequestSpecification contentType(String contentType) {
    notNull contentType, "Content-Type header cannot be null"
    allowContentType = true
    header(CONTENT_TYPE, contentType)
  }

  RequestSpecification noContentType() {
    allowContentType = false
    removeHeader(CONTENT_TYPE)
  }

  RequestSpecification accept(ContentType contentType) {
    notNull contentType, "Accept header"
    accept(contentType.getAcceptHeader())
  }

  RequestSpecification accept(String mediaTypes) {
    notNull mediaTypes, "Accept header media range"
    header(ACCEPT_HEADER_NAME, mediaTypes)
  }

  RequestSpecification headers(Map headers) {
    notNull headers, "headers"
    def headerList = []
    if (this.requestHeaders.exist()) {
      headerList.addAll(this.requestHeaders.list())
    }
    headers.each {
      if (it.value instanceof List) {
        it.value.each { val ->
          headerList << new Header(it.key, serializeIfNeeded(val))
        }
      } else {
        headerList << new Header(it.key, serializeIfNeeded(it.value))
      }
    }
    headerList = removeMergedHeadersIfNeeded(headerList)
    this.requestHeaders = new Headers(headerList)
    return this
  }

  RequestSpecification headers(Headers headers) {
    notNull headers, "headers"
    if (headers.exist()) {
      def headerList = []
      if (this.requestHeaders.exist()) {
        headerList.addAll(this.requestHeaders.list())
      }

      headerList.addAll(headers.headers.list())
      headerList = removeMergedHeadersIfNeeded(headerList)
      this.requestHeaders = new Headers(headerList)
    }
    this
  }

  private List removeMergedHeadersIfNeeded(List headerList) {
    def headers = headerList.inject([], { acc, header ->
      def headerConfig = restAssuredConfig().getHeaderConfig()
      String headerName = header.getName()
      if (headerConfig.shouldOverwriteHeaderWithName(headerName)) {
        acc = acc.findAll { !headerName.equalsIgnoreCase(it.getName()) }
      }
      acc.add(header)
      acc
    })
    headers
  }

  RequestSpecification header(String headerName, Object headerValue, Object... additionalHeaderValues) {
    notNull headerName, "Header name"
    notNull headerValue, "Header value"

    def headerList = [new Header(headerName, serializeIfNeeded(headerValue))]
    additionalHeaderValues?.each {
      headerList << new Header(headerName, serializeIfNeeded(it))
    }

    return headers(new Headers(headerList))
  }

  RequestSpecification header(Header header) {
    notNull header, "Header"

    return headers(new Headers(asList(header)))
  }

  RequestSpecification headers(String firstHeaderName, Object firstHeaderValue, Object... headerNameValuePairs) {
    return headers(MapCreator.createMapFromParams(CollisionStrategy.MERGE, firstHeaderName, firstHeaderValue, headerNameValuePairs))
  }

  RequestSpecification cookies(String firstCookieName, Object firstCookieValue, Object... cookieNameValuePairs) {
    return cookies(MapCreator.createMapFromParams(CollisionStrategy.OVERWRITE, firstCookieName, firstCookieValue, cookieNameValuePairs))
  }

  RequestSpecification cookies(Map cookies) {
    notNull cookies, "cookies"
    def cookieList = []
    if (this.cookies.exist()) {
      cookieList.addAll(this.cookies.list())
    }
    cookies.each {
      cookieList << new Cookie.Builder(it.key, it.value).build()
    }
    this.cookies = new Cookies(cookieList)
    return this
  }

  RequestSpecification cookies(Cookies cookies) {
    notNull cookies, "cookies"
    if (cookies.exist()) {
      def cookieList = []
      if (this.cookies.exist()) {
        cookieList.addAll(this.cookies.list())
      }

      cookieList.addAll(cookies.cookies.list())
      this.cookies = new Cookies(cookieList)
    }
    this
  }

  RequestSpecification cookie(String cookieName, Object value, Object... additionalValues) {
    notNull cookieName, "Cookie name"
    def cookieList = [new Cookie.Builder(cookieName, serializeIfNeeded(value)).build()]
    additionalValues?.each {
      cookieList << new Cookie.Builder(cookieName, serializeIfNeeded(it)).build()
    }

    return cookies(new Cookies(cookieList))
  }

  RequestSpecification cookie(Cookie cookie) {
    notNull cookie, "Cookie"
    return cookies(new Cookies(asList(cookie)))
  }

  RequestSpecification cookie(String cookieName) {
    cookie(cookieName, null)
  }

  RedirectSpecification redirects() {
    new RedirectSpecificationImpl(this, httpClientParams)
  }

  RequestSpecification spec(RequestSpecification requestSpecificationToMerge) {
    SpecificationMerger.merge this, requestSpecificationToMerge
    return this
  }

  RequestSpecification specification(RequestSpecification requestSpecificationToMerge) {
    return spec(requestSpecificationToMerge)
  }

  RequestSpecification sessionId(String sessionIdValue) {
    def sessionIdName = config == null ? SessionConfig.DEFAULT_SESSION_ID_NAME : config.getSessionConfig().sessionIdName()
    sessionId(sessionIdName, sessionIdValue)
  }

  RequestSpecification sessionId(String sessionIdName, String sessionIdValue) {
    notNull(sessionIdName, "Session id name")
    notNull(sessionIdValue, "Session id value")
    if (cookies.hasCookieWithName(sessionIdName)) {
      def allOtherCookies = cookies.findAll { !it.getName().equalsIgnoreCase(sessionIdName) }
      allOtherCookies.add(new Cookie.Builder(sessionIdName, sessionIdValue).build())
      this.cookies = new Cookies(allOtherCookies)
    } else {
      cookie(sessionIdName, sessionIdValue)
    }
    this
  }

  RequestSpecification multiPart(MultiPartSpecification multiPartSpec) {
    notNull multiPartSpec, "Multi-part specification"
    def mimeType = multiPartSpec.mimeType
    def content
    if (multiPartSpec.content instanceof File || multiPartSpec.content instanceof InputStream || multiPartSpec.content instanceof byte[]) {
      content = multiPartSpec.content
    } else {
      // Objects ought to be serialized
      if (mimeType == null) {
        mimeType = ANY.matches(requestContentType) ? JSON.toString() : requestContentType
      }
      content = serializeIfNeeded(multiPartSpec.content, mimeType)
    }

    final String controlName
    if (multiPartSpec instanceof MultiPartSpecificationImpl && !multiPartSpec.isControlNameSpecifiedExplicitly()) {
      // We use the default control name if it was not explicitly specified in the multi-part spec
      controlName = restAssuredConfig().getMultiPartConfig().defaultControlName()
    } else {
      controlName = multiPartSpec.controlName
    }

    final String fileName
    if (multiPartSpec instanceof MultiPartSpecificationImpl && !multiPartSpec.isFileNameSpecifiedExplicitly()) {
      // We use the default file name if it was not explicitly specified in the multi-part spec
      fileName = restAssuredConfig().getMultiPartConfig().defaultFileName()
    } else {
      fileName = multiPartSpec.fileName
    }

    def headers = multiPartSpec.headers

    multiParts << new MultiPartInternal(controlName: controlName, content: content, fileName: fileName, charset: multiPartSpec.charset, mimeType: mimeType, headers: headers)
    return this
  }

  RequestSpecification multiPart(String controlName, File file) {
    multiParts << new MultiPartInternal(controlName: controlName, content: file, fileName: file.getName())
    this
  }

  RequestSpecification multiPart(File file) {
    multiParts << new MultiPartInternal(controlName: restAssuredConfig().getMultiPartConfig().defaultControlName(), content: file, fileName: file.getName())
    this
  }

  RequestSpecification multiPart(String controlName, File file, String mimeType) {
    multiParts << new MultiPartInternal(controlName: controlName, content: file, mimeType: mimeType, fileName: file.getName())
    this
  }

  RequestSpecification multiPart(String controlName, Object object) {
    def mimeType = ANY.matches(requestContentType) ? JSON.toString() : requestContentType
    return multiPart(controlName, object, mimeType)
  }

  RequestSpecification multiPart(String controlName, Object object, String mimeType) {
    def possiblySerializedObject = serializeIfNeeded(object, mimeType)
    multiParts << new MultiPartInternal(controlName: controlName, content: possiblySerializedObject, mimeType: mimeType, fileName: restAssuredConfig().getMultiPartConfig().defaultFileName())
    this
  }

  RequestSpecification multiPart(String controlName, String filename, Object object, String mimeType) {
    def possiblySerializedObject = serializeIfNeeded(object, mimeType)
    multiParts << new MultiPartInternal(controlName: controlName, content: possiblySerializedObject, mimeType: mimeType, fileName: filename)
    this
  }

  RequestSpecification multiPart(String name, String fileName, byte[] bytes) {
    multiParts << new MultiPartInternal(controlName: name, content: bytes, fileName: fileName)
    this
  }

  RequestSpecification multiPart(String name, String fileName, byte[] bytes, String mimeType) {
    multiParts << new MultiPartInternal(controlName: name, content: bytes, mimeType: mimeType, fileName: fileName)
    this
  }

  RequestSpecification multiPart(String name, String fileName, InputStream stream) {
    multiParts << new MultiPartInternal(controlName: name, content: stream, fileName: fileName)
    this
  }

  RequestSpecification multiPart(String name, String fileName, InputStream stream, String mimeType) {
    multiParts << new MultiPartInternal(controlName: name, content: stream, mimeType: mimeType, fileName: fileName)
    this
  }

  RequestSpecification multiPart(String name, String contentBody) {
    multiParts << new MultiPartInternal(controlName: name, content: contentBody, fileName: restAssuredConfig().getMultiPartConfig().defaultFileName())
    this
  }

  RequestSpecification multiPart(String name, NoParameterValue contentBody) {
    multiParts << new MultiPartInternal(controlName: name, content: contentBody, fileName: restAssuredConfig().getMultiPartConfig().defaultFileName())
    this
  }

  RequestSpecification multiPart(String name, String contentBody, String mimeType) {
    multiParts << new MultiPartInternal(controlName: name, content: contentBody, mimeType: mimeType, fileName: restAssuredConfig().getMultiPartConfig().defaultFileName())
    this
  }

  def newFilterContext(assertionClosure, filters, properties) {
    if (path?.endsWith("?")) {
      throw new IllegalArgumentException("Request URI cannot end with ?")
    }

    // Set default accept header if undefined
    if (!headers.hasHeaderWithName(ACCEPT_HEADER_NAME)) {
      header(ACCEPT_HEADER_NAME, ANY.getAcceptHeader())
    }

    def tempContentType = defineRequestContentTypeAsString(method)
    if (tempContentType != null) {
      header(CONTENT_TYPE, tempContentType)
    }

    def unnamedPathParamValues = unnamedPathParamsTuples.findAll { it.v2 != null }.collect { it.v2 }
    def uri = partiallyApplyPathParams(path, true, unnamedPathParamValues)
    String requestUriForLogging = generateRequestUriForLogging(uri, method)

    new FilterContextImpl(requestUriForLogging, getUserDefinedPath(), getDerivedPath(uri), uri, path, unnamedPathParamValues.toArray(), method, assertionClosure, filters, properties)
  }

  private String generateRequestUriForLogging(uri, method) {
    def targetUri
    def allQueryParams = [:]

    if (uri.contains("?")) {
      def uriToUse
      if (isFullyQualified(uri)) {
        uriToUse = uri
      } else {
        uriToUse = getTargetPath(uri)
      }

      targetUri = substringBefore(uriToUse, "?")
      def queryParamsDefinedInPath = substringAfter(uri, "?")

      // Add query parameters defined in path to the allQueryParams map
      if (!isBlank(queryParamsDefinedInPath)) {
        def splittedQueryParams = split(queryParamsDefinedInPath, "&")
        splittedQueryParams.each { queryNameWithPotentialValue ->
          String[] splitted = split(queryNameWithPotentialValue, "=", 2)
          def queryParamHasValueDefined = splitted.size() > 1 || queryNameWithPotentialValue.contains("=")
          if (queryParamHasValueDefined) {
            // Handles the special case where the query param is defined with an empty value
            def value = splitted.size() == 1 ? "" : splitted[1]
            allQueryParams.put(splitted[0], value)
          } else {
            allQueryParams.put(splitted[0], new NoParameterValue())
          }
        }
      }
    } else {
      targetUri = uri
    }

    def actualUri = URIBuilder.convertToURI(assembleCompleteTargetPath(targetUri))
    def uriBuilder = new URIBuilder(actualUri, this.urlEncodingEnabled, encoderConfig())

    if (!POST.name().equalsIgnoreCase(method) && !requestParameters?.isEmpty()) {
      allQueryParams << requestParameters
    }

    if (!queryParameters?.isEmpty()) {
      allQueryParams << queryParameters
    }

    if (GET.name().equalsIgnoreCase(method) && !formParameters?.isEmpty()) {
      allQueryParams << formParameters
    }

    if (!allQueryParams.isEmpty()) {
      uriBuilder.addQueryParams(allQueryParams)
    }

    def requestUriForLogging = uriBuilder.toString()
    requestUriForLogging
  }

  @SuppressWarnings("GroovyUnusedDeclaration")
  private
  Response sendRequest(path, assertionClosure, FilterableRequestSpecification requestSpecification, Map filterContextProperties) {
    notNull path, "Path"
    path = extractRequestParamsIfNeeded(path)
    def method = requestSpecification.getMethod()
    def targetUri = getTargetURI(path)
    def targetPath = getTargetPath(path)

    assertCorrectNumberOfPathParams()

    if (!requestSpecification.getHttpClient() instanceof AbstractHttpClient) {
      throw new IllegalStateException(format("Unfortunately Rest Assured only supports Http Client instances of type %s.", AbstractHttpClient.class.getName()))
    }

    def http = new RestAssuredHttpBuilder(responseSpecification, requestHeaders, queryParameters, targetUri, assertionClosure, urlEncodingEnabled,
            config, requestSpecification.getHttpClient() as AbstractHttpClient, allowContentType, responseSpecification.rpr.defaultParser)
    applyProxySettings(http)
    applyRestAssuredConfig(http)
    registerRestAssuredEncoders(http)
    setRequestHeadersToHttpBuilder(http)

    if (cookies.exist()) {
      http.getHeaders() << [Cookie: cookies.collect { it.name + "=" + it.value }.join("; ")]
    }

    // Allow returning a the response
    def restAssuredResponse = new RestAssuredResponseImpl(logRepository: logRepository)
    RestAssuredConfig cfg = config ?: new RestAssuredConfig()
    restAssuredResponse.setSessionIdName(cfg.getSessionConfig().sessionIdName())
    restAssuredResponse.setDecoderConfig(cfg.getDecoderConfig())
    restAssuredResponse.setConnectionManager(http.client.connectionManager)
    restAssuredResponse.setConfig(cfg)
    restAssuredResponse.setFilterContextProperties(filterContextProperties)
    responseSpecification.restAssuredResponse = restAssuredResponse
    def acceptContentType = assertionClosure.getResponseContentType()

    if (shouldApplySSLConfig(http, cfg)) {
      def sslConfig = cfg.getSSLConfig()
      new CertAuthScheme(pathToKeyStore: sslConfig.getPathToKeyStore(), keyStorePassword: sslConfig.getKeyStorePassword(),
              keystoreType: sslConfig.getKeyStoreType(), keyStore: sslConfig.getKeyStore(),
              pathToTrustStore: sslConfig.getPathToTrustStore(), trustStorePassword: sslConfig.getTrustStorePassword(),
              trustStoreType: sslConfig.getTrustStoreType(), trustStore: sslConfig.getTrustStore(),
              port: sslConfig.getPort(), sslSocketFactory: sslConfig.getSSLSocketFactory(), x509HostnameVerifier: sslConfig.getX509HostnameVerifier())
              .authenticate(http)
    }

    authenticationScheme.authenticate(http)

    if (mayHaveBody(method)) {
      if (hasFormParams() && requestBody != null) {
        throw new IllegalStateException("You can either send form parameters OR body content in $method, not both!")
      }
      def bodyContent = createFormParamBodyContent(assembleBodyContent(method))
      if (POST.name().equalsIgnoreCase(method)) {
        http.post(path: targetPath, body: bodyContent,
                allowContentType: allowContentType,
                requestContentType: requestHeaders.getValue(CONTENT_TYPE),
                contentType: acceptContentType) { response, content ->
          if (assertionClosure != null) {
            assertionClosure.call(response, content)
          }
        }
      } else if (PATCH.name().equalsIgnoreCase(method)) {
        http.patch(path: targetPath, body: bodyContent,
                allowContentType: allowContentType,
                requestContentType: requestHeaders.getValue(CONTENT_TYPE),
                contentType: acceptContentType) { response, content ->
          if (assertionClosure != null) {
            assertionClosure.call(response, content)
          }
        }
      } else {
        requestBody = bodyContent
        sendHttpRequest(http, method, acceptContentType, targetPath, assertionClosure)
      }
    } else {
      sendHttpRequest(http, method, acceptContentType, targetPath, assertionClosure)
    }
    return restAssuredResponse
  }

  void assertCorrectNumberOfPathParams() {
    // Path param size is named - (unnamed - named) since named path params may override unnamed if they target the same placeholder
    if (!getRedundantNamedPathParams().isEmpty() || !getRedundantUnnamedPathParamValues().isEmpty() || !getUndefinedPathParamPlaceholders().isEmpty()) {
      def pathParamPlaceholderSize = getPathParamPlaceholders().size()
      def namedPathParams = getNamedPathParams()
      def pathParamSize = namedPathParams.size() + unnamedPathParamsTuples.findAll { it.v2 != null }.findAll {
        !namedPathParams.containsKey(it.v2)
      }.size()

      def redundantNamedPathParams = getRedundantNamedPathParams()
      def redundantUnnamedPathParamValues = getRedundantUnnamedPathParamValues()
      def hasRedundantNamedPathParams = redundantNamedPathParams.size() > 0
      def hasRedundantUnnamedPathParamValues = redundantUnnamedPathParamValues.size() > 0

      final String message
      if (pathParamPlaceholderSize != pathParamSize) {
        message = "Invalid number of path parameters. Expected ${pathParamPlaceholderSize}, was ${pathParamSize}."
      } else {
        message = "Path parameters were not correctly defined."
      }

      String redundantMessage = ""
      if (hasRedundantNamedPathParams || hasRedundantUnnamedPathParamValues) {
        redundantMessage = " Redundant path parameters are: "

        if (hasRedundantNamedPathParams) {
          redundantMessage += "${redundantNamedPathParams.entrySet().join(", ")}"
        }
        if (hasRedundantNamedPathParams && hasRedundantUnnamedPathParamValues) {
          redundantMessage += " and "
        } else if (hasRedundantNamedPathParams && !hasRedundantUnnamedPathParamValues) {
          redundantMessage += "."
        }
        if (hasRedundantUnnamedPathParamValues) {
          redundantMessage += "${redundantUnnamedPathParamValues.join(", ")}."
        }
      }

      String undefinedMessage = ""
      if (!getUndefinedPathParamPlaceholders().isEmpty()) {
        undefinedMessage = " Undefined path parameters are: ${getUndefinedPathParamPlaceholders().join(", ")}."
      }

      throw new IllegalArgumentException("${message}${redundantMessage}${undefinedMessage}")
    }
  }

  boolean shouldApplySSLConfig(http, RestAssuredConfig cfg) {
    URI uri = ((URIBuilder) http.getUri()).toURI()
    if (uri == null) throw new IllegalStateException("a default URI must be set")
    uri.getScheme()?.toLowerCase() == "https" && cfg.getSSLConfig().isUserConfigured() && !(authenticationScheme instanceof CertAuthScheme)
  }

  def applyRestAssuredConfig(HTTPBuilder http) {
    // Decoder config should always be applied regardless if restAssuredConfig is null or not because
    // by default we should support GZIP and DEFLATE decoding.
    applyContentDecoders(http, (restAssuredConfig?.getDecoderConfig() ?: new DecoderConfig()).contentDecoders())
    if (restAssuredConfig != null) {
      applyRedirectConfig(restAssuredConfig.getRedirectConfig())
      applyHttpClientConfig(restAssuredConfig.getHttpClientConfig())
      applyEncoderConfig(http, restAssuredConfig.getEncoderConfig())
      applySessionConfig(restAssuredConfig.getSessionConfig())
    }
    if (!httpClientParams.isEmpty()) {
      def p = http.client.getParams()

      httpClientParams.each { key, value ->
        p.setParameter(key, value)
      }
    }
  }

  private def applyContentDecoders(HTTPBuilder httpBuilder, List<DecoderConfig.ContentDecoder> contentDecoders) {
    def httpBuilderContentEncoders = contentDecoders.collect { contentDecoder -> ContentEncoding.Type.valueOf(contentDecoder.toString()) }.toArray()
    httpBuilder.setContentEncoding(httpBuilderContentEncoders)
  }

  def applySessionConfig(SessionConfig sessionConfig) {
    if (sessionConfig.isSessionIdValueDefined() && !cookies.hasCookieWithName(sessionConfig.sessionIdName())) {
      cookie(sessionConfig.sessionIdName(), sessionConfig.sessionIdValue())
    }
  }

  def applyEncoderConfig(HTTPBuilder httpBuilder, EncoderConfig encoderConfig) {
    httpBuilder.encoders.setEncoderConfig(encoderConfig)
  }

  def applyHttpClientConfig(HttpClientConfig httpClientConfig) {
    ([:].plus(httpClientConfig.params())).each { key, value ->
      putIfAbsent(httpClientParams, key, value)
    }
  }

  def applyRedirectConfig(RedirectConfig redirectConfig) {
    putIfAbsent(httpClientParams, ALLOW_CIRCULAR_REDIRECTS, redirectConfig.allowsCircularRedirects())
    putIfAbsent(httpClientParams, HANDLE_REDIRECTS, redirectConfig.followsRedirects())
    putIfAbsent(httpClientParams, MAX_REDIRECTS, redirectConfig.maxRedirects())
    putIfAbsent(httpClientParams, REJECT_RELATIVE_REDIRECT, redirectConfig.rejectRelativeRedirects())
  }

  private def putIfAbsent(Map map, key, value) {
    if (!map.containsKey(key)) {
      map.put(key, value)
    }
  }

  def assembleBodyContent(httpMethod) {
    if (hasFormParams() && !GET.name().equalsIgnoreCase(httpMethod)) {
      if (POST.name().equalsIgnoreCase(httpMethod)) {
        mergeMapsAndRetainOrder(requestParameters, formParameters)
      } else {
        formParameters
      }
    } else if (multiParts.isEmpty()) {
      requestBody
    } else {
      new byte[0]
    }
  }

  def mergeMapsAndRetainOrder(Map<String, Object> map1, Map<String, Object> map2) {
    def newMap = new LinkedHashMap()
    newMap.putAll(map1)
    newMap.putAll(map2)
    newMap
  }

  def setRequestHeadersToHttpBuilder(HTTPBuilder http) {
    def httpHeaders = http.getHeaders()
    requestHeaders.each { header ->
      def headerName = header.getName()
      def headerValue = header.getValue()
      if (httpHeaders.containsKey(headerName)) {
        def values = [httpHeaders.get(headerName)]
        values << headerValue
        def headerVal = values.flatten()
        httpHeaders.put(headerName, headerVal)
      } else {
        httpHeaders.put(headerName, headerValue)
      }
    }
  }

  private def createFormParamBodyContent(bodyContent) {
    return bodyContent instanceof Map ? createFormParamBody(bodyContent) : bodyContent
  }

  private String getTargetPath(String path) {
    if (isFullyQualified(path)) {
      return new URL(path).getPath()
    }

    def baseUriPath = ""
    if (!(baseUri == null || baseUri == "")) {
      def uri = new URI(baseUri)
      baseUriPath = uri.getPath()
    }
    return mergeAndRemoveDoubleSlash(mergeAndRemoveDoubleSlash(baseUriPath, basePath), path)
  }

  private def registerRestAssuredEncoders(HTTPBuilder http) {
    // Multipart form-data
    if (multiParts.isEmpty()) {
      return
    }

    if (hasFormParams()) {
      convertFormParamsToMultiPartParams()
    }

    def contentTypeAsString = headers.getValue(CONTENT_TYPE)
    def ct = ContentTypeExtractor.getContentTypeWithoutCharset(contentTypeAsString)
    def subType
    if (ct?.toLowerCase()?.startsWith(MULTIPART_CONTENT_TYPE_PREFIX_WITH_SLASH)) {
      subType = substringAfter(ct, MULTIPART_CONTENT_TYPE_PREFIX_WITH_SLASH)
    } else if (ct?.toLowerCase()?.contains(MULTIPART_CONTENT_TYPE_PREFIX_WITH_PLUS)) {
      subType = substringBefore(substringAfter(ct, MULTIPART_CONTENT_TYPE_PREFIX_WITH_PLUS), "+")
    } else {
      throw new IllegalArgumentException("Content-Type $ct is not valid when using multiparts, it must start with \"$MULTIPART_CONTENT_TYPE_PREFIX_WITH_SLASH\" or contain \"$MULTIPART_CONTENT_TYPE_PREFIX_WITH_PLUS\".")
    }

    def charsetFromContentType = CharsetExtractor.getCharsetFromContentType(contentTypeAsString)
    def charsetToUse = isBlank(charsetFromContentType) ? restAssuredConfig().getMultiPartConfig().defaultCharset() : charsetFromContentType
    def boundaryFromContentType = BoundaryExtractor.getBoundaryFromContentType(contentTypeAsString)
    String boundaryToUse = boundaryFromContentType ?: restAssuredConfig().getMultiPartConfig().defaultBoundary()
    boundaryToUse = boundaryToUse ?: generateBoundary()
    if (!boundaryFromContentType) {
      removeHeader(CONTENT_TYPE) // there should only be one
      contentType(contentTypeAsString + "; boundary=\"" + boundaryToUse + "\"")
    }

    def multipartMode = httpClientConfig().httpMultipartMode()
    // For "defaultCharset" to be taken into account we need to 

    http.encoders.putAt ct, { contentType, content ->
      RestAssuredMultiPartEntity entity = new RestAssuredMultiPartEntity(subType, charsetToUse, multipartMode, boundaryToUse)

      multiParts.each {
        def body = it.contentBody
        def controlName = it.controlName
        def headers = it.headers
        if (headers.isEmpty()) {
          entity.addPart(controlName, body)
        } else {
          def builder = FormBodyPartBuilder.create(controlName, body)
          headers.each { name, value ->
            builder.addField(name, value)
          }
          entity.addPart(builder.build())
        }
      }

      entity
    }
  }

  private static String generateBoundary() {
    def alphabet = (('a'..'z') + ('A'..'Z') + ('0'..'9') + '-' + '_').join()
    def rand = new Random()
    def length = rand.nextInt(11) + 30
    (1..length).collect {
      alphabet[rand.nextInt(alphabet.length())]
    }.join()
  }

  private def convertFormParamsToMultiPartParams() {
    def allFormParams = mergeMapsAndRetainOrder(requestParameters, formParameters)
    allFormParams.each {
      if (it.value instanceof List) {
        it.value.each { val ->
          multiPart(it.key, val)
        }
      } else {
        multiPart(it.key, it.value)
      }
    }
    requestParameters.clear()
    formParameters.clear()
  }

  private def sendHttpRequest(HTTPBuilder http, String method, responseContentType, targetPath, assertionClosure) {
    def allQueryParams = mergeMapsAndRetainOrder(requestParameters, queryParameters)
    if (method.equals(GET.name())) {
      allQueryParams = mergeMapsAndRetainOrder(allQueryParams, formParameters)
    }
    def hasBody = (requestBody != null)
    http.request(method, responseContentType, hasBody) {
      uri.path = targetPath

      if (this.allowContentType) {
        setRequestContentType(defineRequestContentTypeAsString(method))
      }

      if (hasBody) {
        body = requestBody
      }

      uri.query = allQueryParams

      Closure closure = assertionClosure.getClosure()
      // response handler for a success response code:
      response.success = closure

      // handler for any failure status code:
      response.failure = closure
    }
  }

  private boolean hasFormParams() {
    return !(requestParameters.isEmpty() && formParameters.isEmpty())
  }

  private boolean mayHaveBody(method) {
    return POST.name().equals(method) || formParameters.size() > 0 || multiParts.size() > 0
  }

  private String extractRequestParamsIfNeeded(String path) {
    if (path.contains("?")) {
      def indexOfQuestionMark = path.indexOf("?")
      String allParamAsString = path.substring(indexOfQuestionMark + 1)
      def keyValueParams = allParamAsString.split("&")
      keyValueParams.each {
        def keyValue = split(it, "=", 2)
        def theKey
        def theValue
        if (keyValue.length < 1 || keyValue.length > 2) {
          throw new IllegalArgumentException("Illegal parameters passed to REST Assured. Parameters was: $keyValueParams")
        } else if (keyValue.length == 1) {
          theKey = keyValue[0]
          theValue = it.contains("=") ? "" : new NoParameterValue()
        } else {
          theKey = keyValue[0]
          theValue = keyValue[1]
        }
        queryParam(theKey, theValue)
      }
      path = path.substring(0, indexOfQuestionMark)
    }
    return path
  }

  private def defineRequestContentTypeAsString(String method) {
    return defineRequestContentType(method)?.toString()
  }

  private def defineRequestContentType(String method) {
    def contentType = headers.getValue(CONTENT_TYPE)
    if (contentType == null) {
      if (multiParts.size() > 0) {
        contentType = MULTIPART_CONTENT_TYPE_PREFIX_WITH_SLASH + restAssuredConfig().getMultiPartConfig().defaultSubtype()
      } else if (GET.name().equals(method) && !formParameters.isEmpty()) {
        contentType = URLENC
      } else if (requestBody == null) {
        contentType = mayHaveBody(method) ? URLENC : null
      } else if (requestBody instanceof byte[]) {
        contentType = BINARY
      } else {
        contentType = TEXT
      }
    }

    if (shouldAppendCharsetToContentType(contentType)) {
      def charset = findEncoderCharsetOrReturnDefault(contentType.toString())
      if (contentType instanceof String) {
        contentType = contentType + "; " + CHARSET + "=" + charset
      } else {
        contentType = contentType.withCharset(charset)
      }
    }
    contentType
  }

  private boolean shouldAppendCharsetToContentType(contentType) {
    contentType != null &&
            !(startsWith(contentType.toString(), MULTIPART_CONTENT_TYPE_PREFIX_WITH_SLASH) || contains(contentType.toString(), MULTIPART_CONTENT_TYPE_PREFIX_WITH_PLUS)) &&
            restAssuredConfig().encoderConfig.shouldAppendDefaultContentCharsetToContentTypeIfUndefined() && (
            isApplicationJsonContentTypeWithDefaultCharsetDefined(contentType) || !(containsIgnoreCase(contentType.toString(), CHARSET) || equalsIgnoreCase(contentType.toString(), APPLICATION_JSON)))
  }

  private boolean isApplicationJsonContentTypeWithDefaultCharsetDefined(contentType) {
    if (!startsWith(contentType.toString().toLowerCase(), APPLICATION_JSON)) {
      return false
    }

    def encoderConfig = getConfig().getEncoderConfig()
    //noinspection GroovyAccessibility
    def contentTypeOrNull = encoderConfig.defaultCharsetForContentTypeOrNull(contentType.toString())
    contentTypeOrNull != null && (contentTypeOrNull != StandardCharsets.UTF_8.name() || encoderConfig.isUserConfigured())
  }

  private String getTargetURI(String path) {
    def uri
    def pathHasScheme = isFullyQualified(path)
    if (pathHasScheme) {
      def url = new URL(path)
      uri = getTargetUriFromUrl(url)
    } else if (isFullyQualified(baseUri)) {
      def baseUriAsUrl = new URL(baseUri)
      uri = getTargetUriFromUrl(baseUriAsUrl)
    } else if (port != RestAssured.UNDEFINED_PORT) {
      uri = "$baseUri:$port"
    } else {
      uri = "$baseUri"
    }
    return uri
  }

  private String getTargetUriFromUrl(URL url) {
    def protocol = url.getProtocol()
    boolean useDefaultHttps = false
    if (this.@port == RestAssured.UNDEFINED_PORT && protocol.equalsIgnoreCase("https")) {
      useDefaultHttps = true
    }

    def builder = new StringBuilder(protocol)
            .append("://")
            .append(url.getAuthority())

    def hasSpecifiedPortExplicitly = this.@port != RestAssured.UNDEFINED_PORT
    if (!hasPortDefined(url) && !useDefaultHttps) {
      if (hasSpecifiedPortExplicitly) {
        builder.append(":")
        builder.append(this.@port)
      } else if (!isFullyQualified(url.toString()) || hasAuthorityEqualToLocalhost(url)) {
        builder.append(":")
        builder.append(DEFAULT_HTTP_TEST_PORT)
      }
    }
    return builder.toString()
  }

  private boolean hasAuthorityEqualToLocalhost(uri) {
    uri.getAuthority().trim().equalsIgnoreCase(LOCALHOST)
  }

  private boolean hasPortDefined(uri) {
    return uri.getPort() != -1
  }


  private def serializeIfNeeded(Object object) {
    serializeIfNeeded(object, requestContentType)
  }

  private def serializeIfNeeded(Object object, contentType) {
    isSerializableCandidate(object) ? ObjectMapping.serialize(object, contentType, findEncoderCharsetOrReturnDefault(contentType), null, objectMappingConfig(), restAssuredConfig().getEncoderConfig()) : object.toString()
  }

  private def applyPathParamsAndSendRequest(String method, String path, Object... unnamedPathParams) {
    notNull path, "path"
    notNull trimToNull(method), "Method"
    notNull unnamedPathParams, "Path params"
    this.method = method.trim().toUpperCase()
    this.path = path
    if (unnamedPathParams != null) {
      def nullParamIndices = []
      for (int i = 0; i < unnamedPathParams.length; i++) {
        if (unnamedPathParams[i] == null) {
          nullParamIndices << i
        }
      }
      if (!nullParamIndices.isEmpty()) {
        def sizeOne = nullParamIndices.size() == 1
        throw new IllegalArgumentException("Unnamed path parameter cannot be null (path parameter${sizeOne ? "" : "s"} at ${sizeOne ? "index" : "indices"} ${nullParamIndices.join(",")} ${sizeOne ? "is" : "are"} null)")
      }

      buildUnnamedPathParameterTuples(unnamedPathParams)
    }
    if (authenticationScheme instanceof NoAuthScheme && !(defaultAuthScheme instanceof NoAuthScheme)) {
      // Use default auth scheme
      authenticationScheme = defaultAuthScheme
    }

    if (authenticationScheme instanceof FormAuthScheme) {
      // Form auth scheme is handled a bit differently than other auth schemes since it's implemented by a filter.
      def formAuthScheme = authenticationScheme as FormAuthScheme
      filters.removeAll { AuthFilter.class.isAssignableFrom(it.getClass()) }
      filters.add(0, new FormAuthFilter(userName: formAuthScheme.userName, password: formAuthScheme.password, formAuthConfig: formAuthScheme.config, sessionConfig: sessionConfig()))
    }
    def logConfig = restAssuredConfig().getLogConfig()
    if (logConfig.isLoggingOfRequestAndResponseIfValidationFailsEnabled()) {
      if (!filters.any { RequestLoggingFilter.class.isAssignableFrom(it.getClass()) }) {
        log().ifValidationFails(logConfig.logDetailOfRequestAndResponseIfValidationFails(), logConfig.isPrettyPrintingEnabled())
      }
      if (!filters.any { ResponseLoggingFilter.class.isAssignableFrom(it.getClass()) }) {
        responseSpecification.log().ifValidationFails(logConfig.logDetailOfRequestAndResponseIfValidationFails(), logConfig.isPrettyPrintingEnabled())
      }
    }
    restAssuredConfig = config ?: new RestAssuredConfig()

    if (!filters.any { ResponseLoggingFilter.class.isAssignableFrom(it.getClass()) } && responseSpecification?.getLogDetail()) {
      filters.add(new ResponseLoggingFilter(responseSpecification.getLogDetail(),
              logConfig.isPrettyPrintingEnabled(), logConfig.defaultStream()))
    }

    // Sort filters by order
    filters = filters.toSorted { f1, f2 -> getFilterOrder(f1) <=> getFilterOrder(f2) }

    // Add timing filter if it has not been added manually
    if (!filters*.getClass().any { TimingFilter.class.isAssignableFrom(it) }) {
      filters << new TimingFilter()
    }

    filters << new SendRequestFilter()
    def ctx = newFilterContext(responseSpecification.assertionClosure, filters.iterator(), [:])
    httpClient = httpClientConfig().httpClientInstance()
    def response = ctx.next(this, responseSpecification)
    responseSpecification.assertionClosure.validate(response)
    return response
  }

  private def applyPathParamsAndSendRequest(Method method, String path, Object... unnamedPathParams) {
    applyPathParamsAndSendRequest(notNull(method, Method.class).name(), path, unnamedPathParams)
  }

  void buildUnnamedPathParameterTuples(Object[] unnamedPathParameterValues) {
    if (unnamedPathParameterValues == null || unnamedPathParameterValues.length == 0) {
      this.unnamedPathParamsTuples = new ArrayList<Tuple2<String, String>>()
    } else {
      // Undefined placeholders since named path params have precedence over unnamed
      def keys = getUndefinedPathParamPlaceholders()
      List<Tuple2<String, String>> list = new ArrayList<>()
      for (int i = 0; i < unnamedPathParameterValues.length; i++) {
        def val = serializeIfNeeded(unnamedPathParameterValues[i])
        def key = i < keys.size() ? keys.get(i) : null
        list.add(new Tuple2<String, String>(key, val))
      }
      this.unnamedPathParamsTuples = list
    }
  }

  String partiallyApplyPathParams(String path, boolean encodePath, List<String> unnamedPathParams) {
    def unnamedPathParamSize = unnamedPathParams?.size() ?: 0

    def host = getTargetURI(path)
    def targetPath = getTargetPath(path)

    def pathWithoutQueryParams = substringBefore(targetPath, "?")
    def shouldAppendSlashAfterEncoding = pathWithoutQueryParams.endsWith("/")
    // The last slash is removed later so we may need to add it again
    def queryParams = substringAfter(path, "?")

    int numberOfUnnamedPathParametersUsed = 0
    def pathParamNameUsageCount = [:].withDefault { 0 }

    def pathTemplate = ~/.*\{\w+\}.*/
    // If a path fragment contains double slash we need to replace it with something else to not mess up the path
    def hasPathParameterWithDoubleSlash = indexOf(pathWithoutQueryParams, DOUBLE_SLASH) != -1

    def tempParams
    if (hasPathParameterWithDoubleSlash) {
      tempParams = replace(pathWithoutQueryParams, DOUBLE_SLASH, "RA_double_slash__")
    } else {
      tempParams = pathWithoutQueryParams
    }

    def pathParamFiller = { String separator, boolean performEncode, String acc, String subresource ->
      def indexOfStartBracket
      def indexOfEndBracket = 0
      while ((indexOfStartBracket = subresource.indexOf(TEMPLATE_START, indexOfEndBracket)) >= 0) {
        indexOfEndBracket = subresource.indexOf(TEMPLATE_END, indexOfStartBracket)
        // 3 means "{" and "}" and at least one character
        if (indexOfStartBracket >= 0 && indexOfEndBracket >= 0 && subresource.length() >= 3) {
          def pathParamValue
          def pathParamName = subresource.substring(indexOfStartBracket + 1, indexOfEndBracket)
          // Get path parameter name, what's between the "{" and "}"
          def value = findNamedPathParamValue(pathParamName, pathParamNameUsageCount)
          if (value == null && numberOfUnnamedPathParametersUsed < unnamedPathParamSize && unnamedPathParams[numberOfUnnamedPathParametersUsed].toString() != null) {
            pathParamValue = unnamedPathParams[numberOfUnnamedPathParametersUsed].toString()
            numberOfUnnamedPathParametersUsed += 1
          } else {
            // We return the template again if no match found since we might be interested in partially applied path
            pathParamValue = value == null ? TEMPLATE_START + pathParamName + TEMPLATE_END : value
          }

          def pathToPrepend = ""
          // If declared subresource has values before the first bracket then let's find it.
          if (indexOfStartBracket != 0) {
            pathToPrepend = subresource.substring(0, indexOfStartBracket)
          }

          def pathToAppend = ""
          // If declared subresource has values after the first bracket then let's find it.
          if (subresource.length() > indexOfEndBracket) {
            pathToAppend = subresource.substring(indexOfEndBracket + 1, subresource.length())
          }

          // Since the value of the path parameter might be shorter than the template name we need to
          // adjust the "indexOfEndBracket" index in case this subresource contains more templates after
          // this value.
          def lengthOfTemplate = length(pathParamName) + 2 // 2 because "{" and "}"
          def lengthOfValue = length(pathParamValue)
          if (lengthOfTemplate != lengthOfValue) {
            if (lengthOfTemplate > lengthOfValue) {
              indexOfEndBracket -= (lengthOfTemplate - lengthOfValue)
            } else {
              indexOfEndBracket += (lengthOfValue - lengthOfTemplate)
            }
          }

          subresource = pathToPrepend + pathParamValue + pathToAppend
        }
      }
      format("%s${separator}%s", acc, performEncode ? encode(subresource, EncodingTarget.QUERY) : subresource).toString()
    }

    pathWithoutQueryParams = split(tempParams, "/").inject("", pathParamFiller.curry("/", encodePath))

    if (hasPathParameterWithDoubleSlash) {
      // Now get the double slash replacement back to normal double slashes
      pathWithoutQueryParams = replace(pathWithoutQueryParams, "RA_double_slash__", encode(DOUBLE_SLASH, EncodingTarget.QUERY))
    }

    if (shouldAppendSlashAfterEncoding) {
      pathWithoutQueryParams += "/"
    }

    if (queryParams.matches(pathTemplate)) {
      // Note that we do NOT url encode query params here, that happens by UriBuilder at a later stage.
      queryParams = split(queryParams, "&").inject("", pathParamFiller.curry("&", false)).substring(1)
      // 1 means that we remove first & since query parameters starts with ?

    }
    host + (isEmpty(queryParams) ? pathWithoutQueryParams : pathWithoutQueryParams + "?" + queryParams)
  }


  private String findNamedPathParamValue(String pathParamName, pathParamNameUsageCount) {
    def pathParamValues = this.namedPathParameters.get(pathParamName)
    def pathParamValue
    if (pathParamValues instanceof Collection) {
      def pathParamCount = pathParamNameUsageCount[pathParamName]
      pathParamNameUsageCount[pathParamName] = pathParamCount++
      pathParamValue = pathParamValues.get(pathParamCount)
    } else {
      pathParamValue = pathParamValues
    }
    pathParamValue?.toString()
  }

  private String createFormParamBody(Map<String, Object> formParams) {
    final StringBuilder body = new StringBuilder()
    for (Entry<String, Object> entry : formParams.entrySet()) {
      body.append(encode(entry.getKey(), EncodingTarget.BODY))
      if (!(entry.getValue() instanceof NoParameterValue)) {
        body.append("=").append(handleMultiValueParamsIfNeeded(entry))
      }
      body.append("&")
    }
    if (!formParams.isEmpty()) {
      body.deleteCharAt(body.length() - 1) //Delete last &
    }
    return body.toString()
  }


  private String encode(Object string, EncodingTarget encodingType) {
    string = string.toString()
    if (urlEncodingEnabled) {
      def charset
      if (encodingType == EncodingTarget.BODY) {
        charset = encoderConfig().defaultContentCharset()
        def contentType = headers.getValue(CONTENT_TYPE)
        if (contentType instanceof String) {
          def tempCharset = CharsetExtractor.getCharsetFromContentType(contentType as String)
          if (tempCharset != null) {
            charset = tempCharset
          } else if (encoderConfig().hasDefaultCharsetForContentType(contentType as String)) {
            charset = encoderConfig().defaultCharsetForContentType(contentType as String)
          }
        }
      } else { // Query or path parameter
        charset = encoderConfig().defaultQueryParameterCharset()
      }
      return URIBuilder.encode(string, charset)
    } else {
      return string
    }
  }

  private def handleMultiValueParamsIfNeeded(Entry<String, Object> entry) {
    def value = entry.getValue()
    if (value instanceof List) {
      def key = encode(entry.getKey(), EncodingTarget.BODY)
      final StringBuilder multiValueList = new StringBuilder()
      value.eachWithIndex { val, index ->
        multiValueList.append(encode(val.toString(), EncodingTarget.BODY))
        if (index != value.size() - 1) {
          multiValueList.append("&").append(key).append("=")
        }
      }
      value = multiValueList.toString()
    } else {
      value = encode(value, EncodingTarget.BODY)
    }
    return value
  }

  void setResponseSpecification(ResponseSpecification responseSpecification) {
    this.responseSpecification = responseSpecification
  }

  String getBaseUri() {
    return baseUri
  }

  String getBasePath() {
    return basePath
  }

  String getDerivedPath() {
    def uri = partiallyApplyPathParams(path, true, unnamedPathParamsTuples.collect { it.v2 })
    getDerivedPath(uri)
  }

  String getUserDefinedPath() {
    return PathSupport.getPath(path)
  }

  String getMethod() {
    return method
  }

  String getURI() {
    def uri = partiallyApplyPathParams(path, true, unnamedPathParamsTuples.collect { it.v2 })
    getURI(uri)
  }

  int getPort() {
    def host = new URL(getTargetURI(path))
    return host.getPort()
  }

  Map<String, String> getFormParams() {
    return Collections.unmodifiableMap(formParameters)
  }

  Map<String, String> getPathParams() {
    def namedPathParams = getNamedPathParams()
    def map = new LinkedHashMap<String, String>(namedPathParams)
    map.putAll(getUnnamedPathParams().findAll { !namedPathParams.keySet().contains(it.key) })
    return Collections.unmodifiableMap(map)
  }

  Map<String, String> getNamedPathParams() {
    return Collections.unmodifiableMap(namedPathParameters)
  }

  Map<String, String> getUnnamedPathParams() {
    // If it.v1 = null means that it's a placeholder
    def map = unnamedPathParamsTuples.findAll { it.v1 != null }.inject([:], { m, t ->
      m.putAt(t.v1, t.v2)
      m
    })
    return Collections.unmodifiableMap(map)
  }

  List<String> getUnnamedPathParamValues() {
    return Collections.unmodifiableList(unnamedPathParamsTuples == null ? Collections.emptyList() : unnamedPathParamsTuples.findAll {
      it.v2 != null
    }.collect {
      it.v2
    })
  }

  Map<String, String> getRequestParams() {
    return Collections.unmodifiableMap(requestParameters)
  }

  Map<String, String> getQueryParams() {
    return Collections.unmodifiableMap(queryParameters)
  }

  List<MultiPartSpecification> getMultiPartParams() {
    return multiParts.collect {
      new MultiPartSpecificationImpl(content: it.content, charset: it.charset, fileName: it.fileName, mimeType: it.mimeType, controlName: it.controlName, headers: it.headers)
    }
  }

  Headers getHeaders() {
    return requestHeaders
  }

  Cookies getCookies() {
    return cookies
  }

  def getBody() {
    requestBody
  }

  List<Filter> getDefinedFilters() {
    return Collections.unmodifiableList(filters)
  }

  RestAssuredConfig getConfig() {
    return restAssuredConfig
  }

  HttpClient getHttpClient() {
    return httpClient
    // @Delegate doesn't work because of http://jira.codehaus.org/browse/GROOVY-4647 (when it's fixed 9619c3b should be used instead)
  }

  ProxySpecification getProxySpecification() {
    return proxySpecification
  }

  FilterableRequestSpecification path(String path) {
    notNull path, "Path"
    this.path = trimToEmpty(path)
    return this
  }

  List<String> getUndefinedPathParamPlaceholders() {
    def uri = partiallyApplyPathParams(path, false, unnamedPathParamsTuples.collect { it.v2 })
    getPlaceholders(uri)
  }

  List<String> getPathParamPlaceholders() {
    def uri = getTargetPath(contains(path, "://") ? substringAfter(path, "://") : path)
    getPlaceholders(uri)
  }

  String getRequestContentType() {
    return getContentType()
  }

  @Override
  String getContentType() {
    return requestHeaders.getValue(CONTENT_TYPE)
  }

  @Override
  RequestSpecification noFilters() {
    this.filters.clear()
    this
  }

  @Override
  RequestSpecification noFiltersOfType(Class filterType) {
    notNull filterType, "Filter type"
    this.filters.removeAll { filterType.isAssignableFrom(it.getClass()) }
    this
  }

  private def applyProxySettings(RestAssuredHttpBuilder http) {
    // make client aware of JRE proxy settings http://freeside.co/betamax/
    http.client.routePlanner = new RestAssuredProxySelectorRoutePlanner(http.client.connectionManager.schemeRegistry,
            new RestAssuredProxySelector(delegatingProxySelector: ProxySelector.default, proxySpecification: proxySpecification), proxySpecification)
    if (proxySpecification?.hasAuth()) {
      CredentialsProvider credsProvider = new BasicCredentialsProvider()
      def address = new InetSocketAddress(proxySpecification.host, proxySpecification.port)
      // We need to convert the host to an IP since that's what our proxy selector (RestAssuredProxySelector) expects
      def authScope = new AuthScope(address.getAddress().getHostAddress(), proxySpecification.getPort())
      def credentials = new UsernamePasswordCredentials(proxySpecification.username, proxySpecification.password)
      credsProvider.setCredentials(authScope, credentials)
      http.client.setCredentialsProvider(credsProvider)
    }
  }

  private String assembleCompleteTargetPath(requestPath) {
    def targetUri
    def targetPath
    if (isFullyQualified(requestPath)) {
      targetUri = ""
      targetPath = ""
    } else {
      targetUri = getTargetURI(path)
      targetPath = substringBefore(getTargetPath(path), "?")
    }
    return mergeAndRemoveDoubleSlash(mergeAndRemoveDoubleSlash(targetUri, targetPath), requestPath)
  }

  private String findEncoderCharsetOrReturnDefault(String contentType) {
    def charset = CharsetExtractor.getCharsetFromContentType(contentType)
    if (charset == null) {
      final EncoderConfig cfg
      if (config == null) {
        cfg = new EncoderConfig()
      } else {
        cfg = config.getEncoderConfig()
      }

      if (cfg.hasDefaultCharsetForContentType(contentType)) {
        charset = cfg.defaultCharsetForContentType(contentType)
      } else {
        charset = cfg.defaultContentCharset()
      }
    }
    charset
  }

  private ObjectMapperConfig objectMappingConfig() {
    return config == null ? ObjectMapperConfig.objectMapperConfig() : config.getObjectMapperConfig()
  }

  private HttpClientConfig httpClientConfig() {
    return config == null ? HttpClientConfig.httpClientConfig() : config.getHttpClientConfig()
  }

  private ConnectionConfig connectionConfig() {
    return config == null ? ConnectionConfig.connectionConfig() : config.getConnectionConfig()
  }

  private EncoderConfig encoderConfig() {
    return config == null ? EncoderConfig.encoderConfig() : config.getEncoderConfig()
  }

  private SessionConfig sessionConfig() {
    return config == null ? SessionConfig.sessionConfig() : config.getSessionConfig()
  }

  RestAssuredConfig restAssuredConfig() {
    config ?: new RestAssuredConfig()
  }

  private enum EncodingTarget {
    BODY, QUERY
  }

  static List getPlaceholders(String uri) {
    Pattern p = Pattern.compile(Pattern.quote(TEMPLATE_START) + "(.*?)" + Pattern.quote(TEMPLATE_END))
    Matcher m = p.matcher(uri)
    def placeholders = new LinkedHashSet<String>() // Remove duplicates such as if we have get("/{x}/{x}")
    while (m.find()) {
      placeholders << m.group(1)?.trim()
    }
    return Collections.unmodifiableList(new ArrayList(placeholders))
  }

  static String getDerivedPath(String uri) {
    PathSupport.getPath(uri)
  }

  String getURI(String uri) {
    generateRequestUriForLogging(uri, method)
  }

  // Note that it's not possible to both redundant named and unnamed path parameters
  // as a map since redundant unnamed path parameters doesn't necessarily have a placeholder associated with it.
  // For example if we do get("/{x}", "1", "2") then there's no placeholder name for "2"
  Map<String, String> getRedundantNamedPathParams() {
    def placeholders = getPathParamPlaceholders()
    getNamedPathParams().findAll { !placeholders.contains(it.key) }.asImmutable()
  }

  List<String> getRedundantUnnamedPathParamValues() {
    def allPathParams = getPathParams()
    if (getPathParamPlaceholders().minus(allPathParams.keySet()).size() +
            Math.max(getUnnamedPathParamValues().size() - getPathParamPlaceholders().size(), 0) > 0) {
      return (getUnnamedPathParamValues().minus(allPathParams.values())).asImmutable()
    }
    Collections.unmodifiableList(Collections.emptyList())
  }

  void removeUnnamedPathParamAtIndex(int indexOfParamName) {
    unnamedPathParamsTuples.remove(indexOfParamName)
    // We define the a tuple with "null, null" in order to retain path parameter order
    unnamedPathParamsTuples.add(indexOfParamName, new Tuple2<String, String>(null, null))
  }

  void setMethod(String method) {
    this.method = method == null ? null : method.toUpperCase()
  }

  private static int getFilterOrder(Filter filter) {
    return (filter instanceof OrderedFilter) ? ((OrderedFilter) filter).getOrder()
            : OrderedFilter.DEFAULT_PRECEDENCE
  }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-08-31 16:37:43.958
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-08-31 16:37:43.958
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.debug 4 125 2022-08-31 18:27:55.724
!MESSAGE Internal error logged from JDI Debug: 
!STACK 1
org.eclipse.debug.core.DebugException: Invalid stack frame
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1371)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingThisObject(JDIStackFrame.java:1006)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getThis(JDIStackFrame.java:1425)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:376)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SUBENTRY 1 org.eclipse.jdt.debug 4 100 2022-08-31 18:27:55.728
!MESSAGE Invalid stack frame

!ENTRY org.eclipse.ui.ide 4 4 2022-08-31 20:49:47.618
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:683)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:274)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:287)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:265)
	at cucumber.eclipse.editor.editors.GherkinKeywordsAssistProcessor.<init>(GherkinKeywordsAssistProcessor.java:34)
	at cucumber.eclipse.editor.editors.GherkinConfiguration.getContentAssistant(GherkinConfiguration.java:128)
	at org.eclipse.jface.text.source.SourceViewer.configure(SourceViewer.java:500)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3377)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at cucumber.eclipse.editor.editors.Editor.createPartControl(Editor.java:88)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.createElement(PartServiceImpl.java:1303)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.showPart(PartServiceImpl.java:1264)
	at org.eclipse.ui.internal.WorkbenchPartReference.getPart(WorkbenchPartReference.java:397)
	at org.eclipse.ui.internal.EditorReference.getEditor(EditorReference.java:283)
	at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:3149)
	at org.eclipse.ui.internal.WorkbenchPage.lambda$9(WorkbenchPage.java:3100)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3098)
	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3068)
	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3059)
	at org.eclipse.ui.ide.IDE.openEditor(IDE.java:569)
	at org.eclipse.ui.ide.IDE.openEditor(IDE.java:524)
	at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.openInEditor(EditorUtility.java:367)
	at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.openInEditor(EditorUtility.java:172)
	at org.eclipse.jdt.ui.actions.OpenAction.run(OpenAction.java:283)
	at org.eclipse.jdt.ui.actions.OpenAction.run(OpenAction.java:249)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:274)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:252)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerActionGroup.handleOpen(PackageExplorerActionGroup.java:366)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerPart$3.open(PackageExplorerPart.java:545)
	at org.eclipse.ui.OpenAndLinkWithEditorHelper$InternalListener.open(OpenAndLinkWithEditorHelper.java:48)
	at org.eclipse.jface.viewers.StructuredViewer$2.run(StructuredViewer.java:802)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.StructuredViewer.fireOpen(StructuredViewer.java:799)
	at org.eclipse.jface.viewers.StructuredViewer.handleOpen(StructuredViewer.java:1118)
	at org.eclipse.jface.util.OpenStrategy.fireOpenEvent(OpenStrategy.java:275)
	at org.eclipse.jface.util.OpenStrategy.access$2(OpenStrategy.java:270)
	at org.eclipse.jface.util.OpenStrategy$1.handleEvent(OpenStrategy.java:310)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)
!SESSION 2022-09-03 10:34:23.692 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-09-03 10:35:54.685
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-09-03 10:35:54.685
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@67784537,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@17ec5e2a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-09-03 10:35:54.685
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@52290e63,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6c2dd88b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-09-03 10:36:09.119
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\PJain15'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.wildwebdeveloper.xml 4 0 2022-09-03 10:47:32.181
!MESSAGE 
!STACK 0
java.lang.NullPointerException
	at java.base/java.util.Objects.requireNonNull(Objects.java:208)
	at java.base/java.util.ImmutableCollections$MapN.<init>(ImmutableCollections.java:1019)
	at java.base/java.util.Map.of(Map.java:1327)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.toLemMinXOptions(InitializationOptionsProvider.java:26)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.get(InitializationOptionsProvider.java:22)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.get(InitializationOptionsProvider.java:1)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLExtensionRegistry.getInitiatizationOptions(XMLExtensionRegistry.java:135)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.getInitializationOptions(XMLLanguageServer.java:158)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$8(LanguageServerWrapper.java:353)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1146)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1769)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.lsp4e 4 0 2022-09-03 10:48:34.560
!MESSAGE 
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1950)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2085)
	at org.eclipse.lsp4e.operations.hover.LSPTextHover.getHoverRegion(LSPTextHover.java:150)
	at org.eclipse.ui.internal.genericeditor.hover.CompositeTextHover.getHoverRegion(CompositeTextHover.java:101)
	at org.eclipse.jface.text.TextViewerHoverManager.computeInformation(TextViewerHoverManager.java:128)
	at org.eclipse.jface.text.AbstractInformationControlManager.doShowInformation(AbstractInformationControlManager.java:1101)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager$MouseTracker.mouseHover(AbstractHoverInformationControlManager.java:511)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:212)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.lsp4e 4 0 2022-09-03 10:48:35.065
!MESSAGE 
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1950)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2085)
	at org.eclipse.lsp4e.operations.hover.LSPTextHover.getHoverInfo(LSPTextHover.java:73)
	at org.eclipse.ui.internal.genericeditor.hover.CompositeTextHover.getHoverInfo2(CompositeTextHover.java:60)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 4 0 2022-09-03 10:48:35.706
!MESSAGE 
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1950)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2085)
	at org.eclipse.lsp4e.operations.hover.LSPTextHover.getHoverRegion(LSPTextHover.java:150)
	at org.eclipse.ui.internal.genericeditor.hover.CompositeTextHover.getHoverRegion(CompositeTextHover.java:101)
	at org.eclipse.jface.text.TextViewerHoverManager.computeInformation(TextViewerHoverManager.java:128)
	at org.eclipse.jface.text.AbstractInformationControlManager.doShowInformation(AbstractInformationControlManager.java:1101)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager$MouseTracker.mouseHover(AbstractHoverInformationControlManager.java:511)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:212)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.lsp4e 4 0 2022-09-03 10:48:36.208
!MESSAGE 
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1950)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2085)
	at org.eclipse.lsp4e.operations.hover.LSPTextHover.getHoverInfo(LSPTextHover.java:73)
	at org.eclipse.ui.internal.genericeditor.hover.CompositeTextHover.getHoverInfo2(CompositeTextHover.java:60)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 4 0 2022-09-03 10:50:16.433
!MESSAGE org.eclipse.lsp4j.jsonrpc.ResponseErrorException: The request (id: 22, method: 'textDocument/completion') has been cancelled
!STACK 0
java.util.concurrent.ExecutionException: org.eclipse.lsp4j.jsonrpc.ResponseErrorException: The request (id: 22, method: 'textDocument/completion') has been cancelled
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:395)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2063)
	at org.eclipse.lsp4e.operations.completion.LSContentAssistProcessor.computeCompletionProposals(LSContentAssistProcessor.java:106)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:352)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:351)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)
Caused by: org.eclipse.lsp4j.jsonrpc.ResponseErrorException: The request (id: 22, method: 'textDocument/completion') has been cancelled
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponse(RemoteEndpoint.java:209)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:193)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$4(LanguageServerWrapper.java:260)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:832)

!ENTRY org.eclipse.m2e.logback.appender 4 0 2022-09-03 10:52:54.815
!MESSAGE Could not read pom.xml
!STACK 1
org.eclipse.core.runtime.CoreException: Could not read pom.xml
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.readModel(MavenImpl.java:579)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.refreshPhase2(ProjectRegistryManager.java:547)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.refresh(ProjectRegistryManager.java:503)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.refresh(ProjectRegistryManager.java:349)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.refresh(ProjectRegistryManager.java:303)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder$BuildMethod.getProjectFacade(MavenBuilder.java:151)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder$BuildMethod.lambda$0(MavenBuilder.java:89)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.executeBare(MavenExecutionContext.java:182)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:156)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:103)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder$BuildMethod.execute(MavenBuilder.java:88)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder.build(MavenBuilder.java:198)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:846)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:229)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:277)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:330)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:333)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:385)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:406)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.apache.maven.model.io.ModelParseException: Duplicated tag: 'build' (position: START_TAG seen ...</dependencies>\r\n\t<build>... @115:9) 
	at org.apache.maven.model.io.DefaultModelReader.read(DefaultModelReader.java:117)
	at org.apache.maven.model.io.DefaultModelReader.read(DefaultModelReader.java:85)
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.readModel(MavenImpl.java:577)
	... 23 more
Caused by: org.codehaus.plexus.util.xml.pull.XmlPullParserException: Duplicated tag: 'build' (position: START_TAG seen ...</dependencies>\r\n\t<build>... @115:9) 
	at org.apache.maven.model.io.xpp3.MavenXpp3Reader.checkFieldWithDuplicate(MavenXpp3Reader.java:140)
	at org.apache.maven.model.io.xpp3.MavenXpp3Reader.parseModel(MavenXpp3Reader.java:2279)
	at org.apache.maven.model.io.xpp3.MavenXpp3Reader.read(MavenXpp3Reader.java:3872)
	at org.apache.maven.model.io.xpp3.MavenXpp3Reader.read(MavenXpp3Reader.java:595)
	at org.apache.maven.model.io.DefaultModelReader.read(DefaultModelReader.java:112)
	... 25 more
!SUBENTRY 1 org.eclipse.m2e.core 4 -1 2022-09-03 10:52:54.815
!MESSAGE Could not read pom.xml
!STACK 0
org.apache.maven.model.io.ModelParseException: Duplicated tag: 'build' (position: START_TAG seen ...</dependencies>\r\n\t<build>... @115:9) 
	at org.apache.maven.model.io.DefaultModelReader.read(DefaultModelReader.java:117)
	at org.apache.maven.model.io.DefaultModelReader.read(DefaultModelReader.java:85)
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.readModel(MavenImpl.java:577)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.refreshPhase2(ProjectRegistryManager.java:547)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.refresh(ProjectRegistryManager.java:503)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.refresh(ProjectRegistryManager.java:349)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.refresh(ProjectRegistryManager.java:303)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder$BuildMethod.getProjectFacade(MavenBuilder.java:151)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder$BuildMethod.lambda$0(MavenBuilder.java:89)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.executeBare(MavenExecutionContext.java:182)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:156)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:103)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder$BuildMethod.execute(MavenBuilder.java:88)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder.build(MavenBuilder.java:198)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:846)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:229)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:277)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:330)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:333)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:385)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:406)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.codehaus.plexus.util.xml.pull.XmlPullParserException: Duplicated tag: 'build' (position: START_TAG seen ...</dependencies>\r\n\t<build>... @115:9) 
	at org.apache.maven.model.io.xpp3.MavenXpp3Reader.checkFieldWithDuplicate(MavenXpp3Reader.java:140)
	at org.apache.maven.model.io.xpp3.MavenXpp3Reader.parseModel(MavenXpp3Reader.java:2279)
	at org.apache.maven.model.io.xpp3.MavenXpp3Reader.read(MavenXpp3Reader.java:3872)
	at org.apache.maven.model.io.xpp3.MavenXpp3Reader.read(MavenXpp3Reader.java:595)
	at org.apache.maven.model.io.DefaultModelReader.read(DefaultModelReader.java:112)
	... 25 more

!ENTRY org.eclipse.m2e.logback.appender 4 0 2022-09-03 10:52:56.488
!MESSAGE Could not read pom.xml
!STACK 1
org.eclipse.core.runtime.CoreException: Could not read pom.xml
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.readModel(MavenImpl.java:579)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.refreshPhase2(ProjectRegistryManager.java:547)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.refresh(ProjectRegistryManager.java:503)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.refresh(ProjectRegistryManager.java:349)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.refresh(ProjectRegistryManager.java:303)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder$BuildMethod.getProjectFacade(MavenBuilder.java:151)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder$BuildMethod.lambda$0(MavenBuilder.java:89)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.executeBare(MavenExecutionContext.java:182)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:156)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:103)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder$BuildMethod.execute(MavenBuilder.java:88)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder.build(MavenBuilder.java:198)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:846)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:229)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:277)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:330)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:333)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:385)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:406)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.apache.maven.model.io.ModelParseException: Duplicated tag: 'build' (position: START_TAG seen ...</dependencies>\r\n\t<build>... @115:9) 
	at org.apache.maven.model.io.DefaultModelReader.read(DefaultModelReader.java:117)
	at org.apache.maven.model.io.DefaultModelReader.read(DefaultModelReader.java:85)
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.readModel(MavenImpl.java:577)
	... 23 more
Caused by: org.codehaus.plexus.util.xml.pull.XmlPullParserException: Duplicated tag: 'build' (position: START_TAG seen ...</dependencies>\r\n\t<build>... @115:9) 
	at org.apache.maven.model.io.xpp3.MavenXpp3Reader.checkFieldWithDuplicate(MavenXpp3Reader.java:140)
	at org.apache.maven.model.io.xpp3.MavenXpp3Reader.parseModel(MavenXpp3Reader.java:2279)
	at org.apache.maven.model.io.xpp3.MavenXpp3Reader.read(MavenXpp3Reader.java:3872)
	at org.apache.maven.model.io.xpp3.MavenXpp3Reader.read(MavenXpp3Reader.java:595)
	at org.apache.maven.model.io.DefaultModelReader.read(DefaultModelReader.java:112)
	... 25 more
!SUBENTRY 1 org.eclipse.m2e.core 4 -1 2022-09-03 10:52:56.488
!MESSAGE Could not read pom.xml
!STACK 0
org.apache.maven.model.io.ModelParseException: Duplicated tag: 'build' (position: START_TAG seen ...</dependencies>\r\n\t<build>... @115:9) 
	at org.apache.maven.model.io.DefaultModelReader.read(DefaultModelReader.java:117)
	at org.apache.maven.model.io.DefaultModelReader.read(DefaultModelReader.java:85)
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.readModel(MavenImpl.java:577)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.refreshPhase2(ProjectRegistryManager.java:547)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.refresh(ProjectRegistryManager.java:503)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.refresh(ProjectRegistryManager.java:349)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.refresh(ProjectRegistryManager.java:303)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder$BuildMethod.getProjectFacade(MavenBuilder.java:151)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder$BuildMethod.lambda$0(MavenBuilder.java:89)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.executeBare(MavenExecutionContext.java:182)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:156)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:103)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder$BuildMethod.execute(MavenBuilder.java:88)
	at org.eclipse.m2e.core.internal.builder.MavenBuilder.build(MavenBuilder.java:198)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:846)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:229)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:277)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:330)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:333)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:385)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:406)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.codehaus.plexus.util.xml.pull.XmlPullParserException: Duplicated tag: 'build' (position: START_TAG seen ...</dependencies>\r\n\t<build>... @115:9) 
	at org.apache.maven.model.io.xpp3.MavenXpp3Reader.checkFieldWithDuplicate(MavenXpp3Reader.java:140)
	at org.apache.maven.model.io.xpp3.MavenXpp3Reader.parseModel(MavenXpp3Reader.java:2279)
	at org.apache.maven.model.io.xpp3.MavenXpp3Reader.read(MavenXpp3Reader.java:3872)
	at org.apache.maven.model.io.xpp3.MavenXpp3Reader.read(MavenXpp3Reader.java:595)
	at org.apache.maven.model.io.DefaultModelReader.read(DefaultModelReader.java:112)
	... 25 more

!ENTRY org.eclipse.lsp4e 4 0 2022-09-03 10:53:35.101
!MESSAGE 
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1950)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2085)
	at org.eclipse.lsp4e.operations.hover.LSPTextHover.getHoverRegion(LSPTextHover.java:150)
	at org.eclipse.ui.internal.genericeditor.hover.CompositeTextHover.getHoverRegion(CompositeTextHover.java:101)
	at org.eclipse.jface.text.TextViewerHoverManager.computeInformation(TextViewerHoverManager.java:128)
	at org.eclipse.jface.text.AbstractInformationControlManager.doShowInformation(AbstractInformationControlManager.java:1101)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager$MouseTracker.mouseHover(AbstractHoverInformationControlManager.java:511)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:212)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.lsp4e 4 0 2022-09-03 10:53:35.604
!MESSAGE 
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1950)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2085)
	at org.eclipse.lsp4e.operations.hover.LSPTextHover.getHoverInfo(LSPTextHover.java:73)
	at org.eclipse.ui.internal.genericeditor.hover.CompositeTextHover.getHoverInfo2(CompositeTextHover.java:60)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.m2e.logback.appender 2 0 2022-09-03 11:11:26.221
!MESSAGE The POM for org.slf4j:slf4j-api:jar:${slf4j.version} is missing, no dependency information available

!ENTRY org.eclipse.m2e.logback.appender 2 0 2022-09-03 11:11:26.236
!MESSAGE The POM for org.slf4j:slf4j-simple:jar:${slf4j.version} is missing, no dependency information available

!ENTRY org.eclipse.m2e.logback.appender 2 0 2022-09-03 11:11:27.600
!MESSAGE The POM for org.slf4j:slf4j-api:jar:${slf4j.version} is missing, no dependency information available

!ENTRY org.eclipse.m2e.logback.appender 2 0 2022-09-03 11:11:27.603
!MESSAGE The POM for org.slf4j:slf4j-simple:jar:${slf4j.version} is missing, no dependency information available

!ENTRY org.eclipse.m2e.logback.appender 4 0 2022-09-03 11:11:29.052
!MESSAGE Could not download sources for org.slf4j:slf4j-api:${slf4j.version}
!STACK 1
org.eclipse.core.runtime.CoreException: Could not resolve artifact org.slf4j:slf4j-api:jar:sources:${slf4j.version}
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.lambda$4(MavenImpl.java:828)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.executeBare(MavenExecutionContext.java:182)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:117)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:103)
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.resolve(MavenImpl.java:796)
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.resolve(MavenImpl.java:773)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.download(DownloadSourcesJob.java:311)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.downloadAttachments(DownloadSourcesJob.java:285)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.downloadMaven(DownloadSourcesJob.java:255)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.downloadFilesAndPopulateToUpdate(DownloadSourcesJob.java:223)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.lambda$0(DownloadSourcesJob.java:152)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.executeBare(MavenExecutionContext.java:182)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:156)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:103)
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.execute(MavenImpl.java:1416)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.run(DownloadSourcesJob.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Missing org.slf4j:slf4j-api:jar:sources:${slf4j.version}
!SUBENTRY 1 org.eclipse.m2e.core 4 -1 2022-09-03 11:11:29.052
!MESSAGE Could not resolve artifact org.slf4j:slf4j-api:jar:sources:${slf4j.version}
!SUBENTRY 2 org.eclipse.m2e.core 4 -1 2022-09-03 11:11:29.052
!MESSAGE Missing org.slf4j:slf4j-api:jar:sources:${slf4j.version}

!ENTRY org.eclipse.m2e.logback.appender 4 0 2022-09-03 11:11:29.838
!MESSAGE Could not download sources for org.slf4j:slf4j-simple:${slf4j.version}
!STACK 1
org.eclipse.core.runtime.CoreException: Could not resolve artifact org.slf4j:slf4j-simple:jar:sources:${slf4j.version}
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.lambda$4(MavenImpl.java:828)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.executeBare(MavenExecutionContext.java:182)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:117)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:103)
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.resolve(MavenImpl.java:796)
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.resolve(MavenImpl.java:773)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.download(DownloadSourcesJob.java:311)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.downloadAttachments(DownloadSourcesJob.java:285)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.downloadMaven(DownloadSourcesJob.java:255)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.downloadFilesAndPopulateToUpdate(DownloadSourcesJob.java:223)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.lambda$0(DownloadSourcesJob.java:152)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.executeBare(MavenExecutionContext.java:182)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:156)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:103)
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.execute(MavenImpl.java:1416)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.run(DownloadSourcesJob.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Missing org.slf4j:slf4j-simple:jar:sources:${slf4j.version}
!SUBENTRY 1 org.eclipse.m2e.core 4 -1 2022-09-03 11:11:29.838
!MESSAGE Could not resolve artifact org.slf4j:slf4j-simple:jar:sources:${slf4j.version}
!SUBENTRY 2 org.eclipse.m2e.core 4 -1 2022-09-03 11:11:29.838
!MESSAGE Missing org.slf4j:slf4j-simple:jar:sources:${slf4j.version}

!ENTRY org.eclipse.m2e.logback.appender 2 0 2022-09-03 11:14:39.389
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2022-09-03 11:14:39.393
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.jface 2 0 2022-09-03 12:30:29.046
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-09-03 12:30:29.046
!MESSAGE A conflict occurred for CTRL+SHIFT+F:
Binding(CTRL+SHIFT+F,
	ParameterizedCommand(Command(org.eclipse.lsp4e.format,Format,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@17055d9e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.textEditorScope,,,system)
Binding(CTRL+SHIFT+F,
	ParameterizedCommand(Command(cucumber.eclipse.editor.formmater.pretty_formatter,Pretty format feature file,
		Format,
		Category(cucumber.eclipse.editor.formmtter,Formatter,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@434085df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	cucumber.eclipse.editor.featureEditorScope,,,system)

!ENTRY org.eclipse.m2e.logback.appender 2 0 2022-09-03 12:39:23.746
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2022-09-03 12:39:23.748
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.wst.xml.search.editor 4 0 2022-09-03 12:40:41.723
!MESSAGE   Could not load contentAssists for id: jetty.default.info
!STACK 1
org.eclipse.core.runtime.CoreException: Plug-in org.eclipse.jst.server.jetty.xml.ui was unable to load class org.eclipse.jst.server.jetty.xml.ui.internal.contentassist.JettyContentAssistAdditionalProposalInfoProvider.
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.throwException(RegistryStrategyOSGI.java:212)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:198)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.wst.xml.search.editor.internal.contentassist.ContentAssistsManager.addContentAssists(ContentAssistsManager.java:66)
	at org.eclipse.wst.xml.search.editor.internal.contentassist.ContentAssistsManager.loadContentAssists(ContentAssistsManager.java:100)
	at org.eclipse.wst.xml.search.editor.internal.contentassist.ContentAssistsManager.getProvider(ContentAssistsManager.java:82)
	at org.eclipse.wst.xml.search.editor.internal.references.XMLReferencePathFactory.getAdditionalProposalInfoProvider(XMLReferencePathFactory.java:232)
	at org.eclipse.wst.xml.search.editor.internal.references.XMLReferencePathFactory.createTo(XMLReferencePathFactory.java:159)
	at org.eclipse.wst.xml.search.editor.internal.references.XMLReferencesManager.parseReferenceDecl(XMLReferencesManager.java:279)
	at org.eclipse.wst.xml.search.editor.internal.references.XMLReferencesManager.addXMLReferences(XMLReferencesManager.java:248)
	at org.eclipse.wst.xml.search.editor.internal.references.XMLReferencesManager.loadXMLReferences(XMLReferencesManager.java:218)
	at org.eclipse.wst.xml.search.editor.internal.references.XMLReferencesManager.loadXMLReferencesIfNeeded(XMLReferencesManager.java:388)
	at org.eclipse.wst.xml.search.editor.internal.references.XMLReferencesManager.getXMLReferences(XMLReferencesManager.java:121)
	at org.eclipse.wst.xml.search.editor.internal.references.XMLReferencesManager.getXMLReference(XMLReferencesManager.java:73)
	at org.eclipse.wst.xml.search.editor.references.XMLReferencesUtil.getXMLReference(XMLReferencesUtil.java:36)
	at org.eclipse.wst.xml.search.editor.references.XMLReferencesUtil.getXMLReference(XMLReferencesUtil.java:32)
	at org.eclipse.wst.xml.search.editor.validation.XMLReferencesValidator.doValidateXMLContent(XMLReferencesValidator.java:63)
	at org.eclipse.wst.xml.search.editor.validation.AbstractTagValidator.doValidate(AbstractTagValidator.java:28)
	at org.eclipse.wst.xml.search.editor.validation.AbstractValidator.validate(AbstractValidator.java:140)
	at org.eclipse.wst.xml.search.editor.validation.AbstractValidator.validate(AbstractValidator.java:122)
	at org.eclipse.wst.xml.search.editor.validation.AbstractValidator.validate(AbstractValidator.java:106)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:207)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)
Caused by: java.lang.ClassNotFoundException: org.eclipse.jst.server.jetty.xml.ui.internal.contentassist.JettyContentAssistAdditionalProposalInfoProvider cannot be found by org.eclipse.jst.server.jetty.xml.ui_1.0.0.201410302229
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:519)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:171)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:617)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	... 28 more
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2022-09-03 12:40:41.723
!MESSAGE Plug-in org.eclipse.jst.server.jetty.xml.ui was unable to load class org.eclipse.jst.server.jetty.xml.ui.internal.contentassist.JettyContentAssistAdditionalProposalInfoProvider.
!STACK 0
java.lang.ClassNotFoundException: org.eclipse.jst.server.jetty.xml.ui.internal.contentassist.JettyContentAssistAdditionalProposalInfoProvider cannot be found by org.eclipse.jst.server.jetty.xml.ui_1.0.0.201410302229
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:519)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:171)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:617)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.wst.xml.search.editor.internal.contentassist.ContentAssistsManager.addContentAssists(ContentAssistsManager.java:66)
	at org.eclipse.wst.xml.search.editor.internal.contentassist.ContentAssistsManager.loadContentAssists(ContentAssistsManager.java:100)
	at org.eclipse.wst.xml.search.editor.internal.contentassist.ContentAssistsManager.getProvider(ContentAssistsManager.java:82)
	at org.eclipse.wst.xml.search.editor.internal.references.XMLReferencePathFactory.getAdditionalProposalInfoProvider(XMLReferencePathFactory.java:232)
	at org.eclipse.wst.xml.search.editor.internal.references.XMLReferencePathFactory.createTo(XMLReferencePathFactory.java:159)
	at org.eclipse.wst.xml.search.editor.internal.references.XMLReferencesManager.parseReferenceDecl(XMLReferencesManager.java:279)
	at org.eclipse.wst.xml.search.editor.internal.references.XMLReferencesManager.addXMLReferences(XMLReferencesManager.java:248)
	at org.eclipse.wst.xml.search.editor.internal.references.XMLReferencesManager.loadXMLReferences(XMLReferencesManager.java:218)
	at org.eclipse.wst.xml.search.editor.internal.references.XMLReferencesManager.loadXMLReferencesIfNeeded(XMLReferencesManager.java:388)
	at org.eclipse.wst.xml.search.editor.internal.references.XMLReferencesManager.getXMLReferences(XMLReferencesManager.java:121)
	at org.eclipse.wst.xml.search.editor.internal.references.XMLReferencesManager.getXMLReference(XMLReferencesManager.java:73)
	at org.eclipse.wst.xml.search.editor.references.XMLReferencesUtil.getXMLReference(XMLReferencesUtil.java:36)
	at org.eclipse.wst.xml.search.editor.references.XMLReferencesUtil.getXMLReference(XMLReferencesUtil.java:32)
	at org.eclipse.wst.xml.search.editor.validation.XMLReferencesValidator.doValidateXMLContent(XMLReferencesValidator.java:63)
	at org.eclipse.wst.xml.search.editor.validation.AbstractTagValidator.doValidate(AbstractTagValidator.java:28)
	at org.eclipse.wst.xml.search.editor.validation.AbstractValidator.validate(AbstractValidator.java:140)
	at org.eclipse.wst.xml.search.editor.validation.AbstractValidator.validate(AbstractValidator.java:122)
	at org.eclipse.wst.xml.search.editor.validation.AbstractValidator.validate(AbstractValidator.java:106)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:207)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wildwebdeveloper.xml 4 0 2022-09-03 12:43:25.157
!MESSAGE 
!STACK 0
java.lang.NullPointerException
	at java.base/java.util.Objects.requireNonNull(Objects.java:208)
	at java.base/java.util.ImmutableCollections$MapN.<init>(ImmutableCollections.java:1019)
	at java.base/java.util.Map.of(Map.java:1327)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.toLemMinXOptions(InitializationOptionsProvider.java:26)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.get(InitializationOptionsProvider.java:22)
	at org.eclipse.m2e.editor.lemminx.InitializationOptionsProvider.get(InitializationOptionsProvider.java:1)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLExtensionRegistry.getInitiatizationOptions(XMLExtensionRegistry.java:135)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.getInitializationOptions(XMLLanguageServer.java:158)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$8(LanguageServerWrapper.java:353)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1146)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1769)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.lsp4e 4 0 2022-09-03 14:23:52.659
!MESSAGE 
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1950)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2085)
	at org.eclipse.lsp4e.operations.hover.LSPTextHover.getHoverRegion(LSPTextHover.java:150)
	at org.eclipse.ui.internal.genericeditor.hover.CompositeTextHover.getHoverRegion(CompositeTextHover.java:101)
	at org.eclipse.jface.text.TextViewerHoverManager.computeInformation(TextViewerHoverManager.java:128)
	at org.eclipse.jface.text.AbstractInformationControlManager.doShowInformation(AbstractInformationControlManager.java:1101)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager$MouseTracker.mouseHover(AbstractHoverInformationControlManager.java:511)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:212)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.lsp4e 4 0 2022-09-03 14:23:53.162
!MESSAGE 
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1950)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2085)
	at org.eclipse.lsp4e.operations.hover.LSPTextHover.getHoverInfo(LSPTextHover.java:73)
	at org.eclipse.ui.internal.genericeditor.hover.CompositeTextHover.getHoverInfo2(CompositeTextHover.java:60)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 4 0 2022-09-03 14:28:42.903
!MESSAGE 
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1950)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2085)
	at org.eclipse.lsp4e.operations.hover.LSPTextHover.getHoverRegion(LSPTextHover.java:150)
	at org.eclipse.ui.internal.genericeditor.hover.CompositeTextHover.getHoverRegion(CompositeTextHover.java:101)
	at org.eclipse.jface.text.TextViewerHoverManager.computeInformation(TextViewerHoverManager.java:128)
	at org.eclipse.jface.text.AbstractInformationControlManager.doShowInformation(AbstractInformationControlManager.java:1101)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager$MouseTracker.mouseHover(AbstractHoverInformationControlManager.java:511)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:212)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.lsp4e 4 0 2022-09-03 14:28:43.408
!MESSAGE 
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1950)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2085)
	at org.eclipse.lsp4e.operations.hover.LSPTextHover.getHoverInfo(LSPTextHover.java:73)
	at org.eclipse.ui.internal.genericeditor.hover.CompositeTextHover.getHoverInfo2(CompositeTextHover.java:60)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 4 0 2022-09-03 14:42:59.215
!MESSAGE 
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1950)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2085)
	at org.eclipse.lsp4e.operations.hover.LSPTextHover.getHoverRegion(LSPTextHover.java:150)
	at org.eclipse.ui.internal.genericeditor.hover.CompositeTextHover.getHoverRegion(CompositeTextHover.java:101)
	at org.eclipse.jface.text.TextViewerHoverManager.computeInformation(TextViewerHoverManager.java:128)
	at org.eclipse.jface.text.AbstractInformationControlManager.doShowInformation(AbstractInformationControlManager.java:1101)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager$MouseTracker.mouseHover(AbstractHoverInformationControlManager.java:511)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:212)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.lsp4e 4 0 2022-09-03 14:42:59.720
!MESSAGE 
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1950)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2085)
	at org.eclipse.lsp4e.operations.hover.LSPTextHover.getHoverInfo(LSPTextHover.java:73)
	at org.eclipse.ui.internal.genericeditor.hover.CompositeTextHover.getHoverInfo2(CompositeTextHover.java:60)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
